# 特权

## Hardware

我们提到了操作系统的主要任务之一是如何实现安全性;这是为了不允许一个应用程序或用户干扰系统中运行的任何其他应用程序或用户。这意味着应用程序不应该覆盖彼此的内存或文件，只能访问系统策略所指示的系统资源。

但是，当应用程序运行时，它独占使用处理器。当我们在下一章中研究过程时，我们会看到它是如何工作的。确保应用程序仅访问它拥有的内存是由虚拟内存系统实现的，我们将在下一章中讨论。关键是硬件负责执行这些规则。

我们检查的系统调用接口是应用程序获取系统资源的网关。通过强制应用程序通过对内核的系统调用来请求资源，内核可以强制执行可以提供哪种访问的规则。例如，当应用程序进行 open（）系统调用以在磁盘上打开文件时，它将根据文件权限检查用户的权限并允许或拒绝访问。

## 特权级(Privilege Levels)

硬件保护通常可以看作围绕核心操作集的一组同心环。

![Rings](http://www.bottomupcs.com/chapter03/figures/priv.png)

在最内圈是最受保护的指令; 那些只允许内核调用的东西。 例如，不应允许用户应用程序运行停止处理器的 HLT 指令，因为它会阻止整个计算机工作。 但是，当计算机合法关闭时，内核需要能够调用此指令。[11]

每个内环可以访问受到更多外环保护的任何指令，但不能进一步受到环的保护。 并非所有架构都具有如上所述的多级环，但是大多数架构将至少提供“内核”和“用户”级别。

### 386 protection model

386 保护模型有四个环，但大多数操作系统（例如 Linux 和 Windows）仅使用两个环来保持与现在允许尽可能多的离散保护级别的其他体系结构的兼容性。

386 通过使在系统中运行的每个应用程序代码具有称为代码描述符的小描述符来维护特权，该描述符除其他之外描述其特权级别。 当运行应用程序代码跳转到其代码描述符描述的区域之外的某些其他代码时，将检查目标的权限级别。 如果它高于当前运行的代码，则硬件不允许跳转（应用程序将崩溃）。

### 提高特权级(Raising Privilege)

应用程序只能通过允许它的特定调用来提高其权限级别，例如实现系统调用的指令。 这些通常被称为呼叫门，因为它们仅用作物理门; 通过一个难以穿透的墙壁进入一个小入口。 当调用该指令时，我们已经看到硬件如何完全停止正在运行的应用程序并将控制权交给内核。 内核必须充当守门人; 确保门口没有任何令人讨厌的东西。 这意味着它必须仔细检查系统调用参数，以确保它不会被愚弄做任何不应该做的事情（如果可能的话，这是一个安全漏洞）。 当内核在最里面的环中运行时，它有权执行它想要的任何操作; 当它完成时，它会将控制权返回给应用程序，该应用程序将再次以较低的权限级别运行。

### Fast System Calls

如上所述的陷阱的一个问题是它们对于处理器来说实施起来非常昂贵。 在上下文切换之前，有很多状态需要保存。 现代处理器已经实现了这种开销，并努力减少它。

要理解上述呼叫门机制，需要研究处理器使用的巧妙但复杂的分段方案。 分段的最初原因是能够在寄存器中使用超过16位的地址，如图“x86分段寻址”所示。

![x86 Segmentation Addressing](http://www.bottomupcs.com/chapter03/figures/ia32-segmentation.png)

当x86移动到32位寄存器时，分段方案仍然保持不同的格式。 而不是固定的段大小，允许段是任何大小。 这意味着处理器需要跟踪所有这些不同的段及其大小，它使用描述符。 每个人都可以使用的段描述符保存在全局描述符表或GDT中。 每个进程都有许多寄存器，指向GDT中的条目; 这些是进程可以访问的段（还有本地描述符表，它们都与任务状态段交互，但现在这并不重要）。 整个情况如图“x86段”所示。

![x86段](http://www.bottomupcs.com/chapter03/figures/ia32-segments.png)

由于操作系统将段寄存器分配为进程状态的一部分，因此处理器硬件知道当前正在运行的进程可以访问哪些内存段，并且可以强制执行保护以确保进程不会触及任何不应该访问的内容。如果确实超出范围，则会收到大多数程序员熟悉的分段错误。

当运行代码需要调用驻留在另一个段中的代码时，图片会变得更有趣。正如在“386保护模型”一节中所讨论的那样，x86使用环来执行此操作，其中环0是最高权限，环3是最低权限，内环可以访问外环但反之亦然。

正如在“提升权限”一节中所讨论的，当环3代码想要跳转到环0代码时，它实质上是修改其代码段选择器以指向不同的段。为此，它必须使用特殊的远程调用指令，硬件确保通过调用门。运行进程没有其他方法可以选择新的代码段描述符，因此处理器将开始在环0段内的已知偏移量处执行代码，该代码负责维护完整性（例如，不读取任意且可能是恶意的代码和执行它。当然，邪恶的攻击者总是会寻找方法让你的代码做你不想要的事情！）。

这允许它们之间的整个层次结构和权限。您可能已经注意到跨段调用听起来与系统调用完全相同。如果你曾经看过Linux x86程序集，那么进行系统调用的标准方法是int 0x80，它会引发中断0x80。中断会停止处理器并进入中断门，然后中断门的工作方式与调用门相同 - 它会更改权限级别并将您反弹到其他一些代码区域。

这个方案的问题是它很慢。完成所有这些检查需要花费很多精力，并且需要保存许多寄存器才能进入新代码。在退出的路上，这一切都需要再次恢复。

在现代x86系统中，由于虚拟内存而不使用四级环系统，第6章虚拟内存将对此进行全面讨论。分段切换真正发生的唯一事情是系统调用，它实际上从模式3（用户空间）切换到模式0并跳转到内核中的系统调用处理程序代码。因此，处理器提供额外的快速系统调用指令，称为sysenter（以及sysexit，以便返回），通过消除远程调用的一般性质，可以在整个过程中加速整个过程 - 这可能会转移到任何段任何环级 - 并限制调用仅转换到特定段和偏移的环0代码，存储在寄存器中。

因为一般性质已经被如此多的先前已知信息所取代，所以整个过程可以加速，因此我们具有上述快速系统调用。另一件需要注意的是，当内核获得控制权时，状态不会被保留。内核必须小心不要破坏状态，但它也意味着它可以自由地只保存完成工作所需的状态，因此可以更加高效。这是一个非常RISC的理念，并说明了RISC和CISC处理器之间的界限是如何模糊的。

有关如何在Linux内核中实现它的更多信息，请参阅“内核库”一节。

## Other ways of communicating with the kernel

### ioctl

about ioctls

### File Systems

about proc, sysfs, debugfs, etc
