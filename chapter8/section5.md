# Libraries

开发人员很快就厌倦了从头开始编写所有东西，因此计算机科学的最早发明之一就是库。

库只是一组函数，您可以从程序中调用它们。 显然，图书馆有许多优点，其中最重要的是你可以通过重复使用其他人已经完成的工作来节省大量时间，并且通常更有信心它有更少的错误（因为可能很多其他人也使用这些库，并且你会受益 让他们找到并修复错误）。 库完全类似于可执行文件，除了直接运行库函数，使用可执行文件中的参数调用库函数。

## Static Libraries

使用库函数最直接的方法是将库中的目标文件直接链接到最终的可执行文件中，就像您自己编译的那些一样。 当像这样链接时，库被称为静态库，因为除非重新编译程序，否则库将保持不变。

这是使用库的最直接方式，因为最终结果是一个没有依赖项的简单可执行文件。

### Inside static libraries

静态库只是一组目标文件。 目标文件保存在存档中，这导致它们通常的.a 后缀扩展名。 您可以将归档视为与 zip 文件类似，但不进行压缩。

下面我们将展示基本静态库的创建，并介绍一些使用库的常用工具。

Creating and using a static library:

```
   $ cat library.c
    /* Library Function */
    int function(int input)
    {
            return input + 10;
    }

    $ cat library.h
    /* Function Definition */
    int function(int);

    $ cat program.c
    #include <stdio.h>
    /* Library header file */
    #include "library.h"

    int main(void)
    {
            int d = function(100);

            printf("%d\n", d);
    }

    $ gcc -c library.c
    $ ar rc libtest.a library.o
    $ ranlib ./libtest.a
    $ nm --print-armap ./libtest.a

    Archive index:
    function in library.o

    library.o:
    00000000 T function

    $ gcc -L . program.c -ltest -o program

    $ ./program
    110
```

首先，我们将库编译为目标文件，就像我们在前一章中看到的那样。

请注意，我们在头文件中定义了库 API。 API 由库中函数的函数定义组成;这样编译器就可以知道在构建引用库的目标文件时函数采用的类型（例如 program.c，其中#include 头文件）。

我们创建库 ar（“archive”的缩写）命令。按照惯例，静态库文件名以 lib 为前缀，扩展名为.a。 c 参数告诉程序创建存档，并告诉存档将指定的目标文件添加到库文件中。

接下来，我们使用 ranlib 应用程序在库中使用目标文件内容的符号创建标头。这有助于编译器快速引用符号;在我们只有一个这个步骤的情况下，这似乎有点多余;但是，大型库可能有数千个符号，这意味着索引可以显着加快查找引用。我们使用 nm 应用程序检查这个新标头。正如我们所期望的那样，我们在偏移零处看到 function（）函数的函数符号。

然后使用-lname 为编译器指定库，其中 name 是不带前缀 lib 的库的文件名。我们还为库提供了额外的搜索目录，即当前目录（-L。），因为默认情况下不搜索当前目录的库。

最终结果是包含新库的单个可执行文件。

### Static Linking Drawbacks

静态链接非常简单，但有许多缺点。

有两个主要缺点; 首先，如果更新库代码（修复错误，比如说），则必须将程序重新编译为新的可执行文件;其次，系统中使用该库的每个程序都在其可执行文件中包含一个副本。 这是非常低效的（如果您发现错误并且必须按照第 1 点重新编译，则会很痛苦）。

例如，C 库（glibc）包含在所有程序中，并提供所有常用功能，如 printf。

## Shared Libraries

共享库是解决静态库带来的问题的一种优雅方式。 共享库是在运行时为需要它的每个应用程序动态加载的库。

应用程序只是留下指针，它将需要一个特定的库，并且在进行函数调用时，库被加载到内存中并执行。 如果已经为另一个应用程序加载了库，则可以在两者之间共享代码，从而为常用库节省大量资源。

这个过程称为动态链接，是现代操作系统中比较复杂的部分之一。 因此，我们将下一章专门用于研究动态链接过程。
