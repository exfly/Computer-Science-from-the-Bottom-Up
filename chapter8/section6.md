# Extending ELF concepts

## Debugging

传统上，事后调试的主要方法称为核心转储。 术语核心来自磁芯存储器的原始物理特性，它使用小磁环的方向来存储状态。

因此，核心转储只是程序在特定时间运行时的完整快照。 然后可以使用调试器检查此转储并重新构建程序状态。 例 8.12“创建核心转储并将其与 gdb 一起使用的示例”显示了一个示例程序，该程序写入随机存储器位置以强制崩溃。 此时，将停止进程并记录当前状态的转储。

```
    $ cat coredump.c
    int main(void) {
    	char *foo = (char*)0x12345;
    	*foo = 'a';

    	return 0;
    }

    $ gcc -Wall -g -o coredump coredump.c

    $ ./coredump
    Segmentation fault (core dumped)

    $ file ./core
    ./core: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from './coredump'

    $ gdb ./coredump
    ...
    (gdb) core core
    [New LWP 31614]
    Core was generated by `./coredump'.
    Program terminated with signal 11, Segmentation fault.
    #0  0x080483c4 in main () at coredump.c:3
    3		*foo = 'a';
    (gdb)
```

### Symbols and Debugging Information

如例 8.12“创建核心转储并将其与 gdb 一起使用的示例”所示，调试器 gdb 需要原始可执行文件和核心转储来重建调试会话的环境。请注意，原始可执行文件是使用-g 标志构建的，该标志指示编译器包含所有调试信息。这些额外的调试信息保存在 ELF 文件的特殊部分中。它详细描述了什么寄存器值当前包含代码中使用的变量，变量大小，数组长度等等。它通常采用标准 DWARF 格式（几乎同义词 ELF 上的双关语）。

包括调试信息可以使可执行文件和库非常大;虽然这些数据不需要驻留在内存中以便实际运行，但它仍然占用相当大的磁盘空间。因此，通常的过程是从 ELF 文件中剥离此信息。虽然可以安排剥离和未剥离文件的传送，但大多数当前的二进制分发方法都在单独的文件中提供调试信息。 objcopy 工具可用于提取调试信息（--only-keep-debug），然后将原始可执行文件中的链接添加到此剥离信息（--add-gnu-debuglink）。完成此操作后，原始可执行文件中将出现一个名为.gnu_debuglink 的特殊部分，其中包含一个哈希，以便在调试会话启动时，调试器可以确保它将正确的调试信息与正确的可执行文件相关联。

例 8.13。使用 objcopy 将调试信息剥离到单独的文件中的示例

```
    $ gcc -g -shared -o libtest.so libtest.c
    $ objcopy --only-keep-debug libtest.so libtest.debug
    $ objcopy --add-gnu-debuglink=libtest.debug libtest.so
    $ objdump -s -j .gnu_debuglink libtest.so

    libtest.so:     file format elf32-i386

    Contents of section .gnu_debuglink:
     0000 6c696274 6573742e 64656275 67000000  libtest.debug...
     0010 52a7fd0a                             R...
```

符号占用的空间要少得多，但也是从最终输出中删除的目标。 一旦可执行文件的各个目标文件链接到单个最终图像中，通常不需要保留大多数符号。 正如在“符号和重定位”一节中所讨论的那样，需要符号来修复重定位条目，但是一旦完成，符号对于运行最终程序并不是绝对必要的。 在 Linux 上，GNU 工具链条带程序提供了删除符号的选项。 请注意，某些符号需要在运行时解析（对于动态链接，第 9 章的重点，动态链接），但这些符号放在单独的动态符号表中，因此不会删除它们并使最终输出无效。

### Inside coredumps

coredump 实际上只是另一个 ELF 文件; 这说明了 ELF 作为二进制格式的灵活性。

```
$ readelf --all ./core
$ eu-readelf -n ./core
```

在例 8.14“使用 readelf 和 eu-readelf 来检查 coredump 的示例。”我们可以看到实例 8.12 生成的核心文件的检查，“创建核心转储并将其与 gdb 一起使用的示例”首先使用 readelf 工具。加载可执行文件或库可能不需要文件中的部分，重定位或其他无关信息;它只包含一系列描述 LOAD 段的程序头。这些段是由内核创建的当前内存分配的原始数据转储。

核心转储的另一个组件是 NOTE 部分，它包含调试所需的数据，但不一定在内存分配的直接快照中捕获。图的第二部分中使用的 eu-readelf 程序通过解码提供了更完整的数据视图。

PRSTATUS 注释提供了有关该过程的一系列有趣信息;例如，我们可以从 cursig 看到程序收到信号 11 或分段错误，正如我们所期望的那样。除了进程号信息外，它还包括所有当前寄存器的转储。给定寄存器值，调试器可以重建堆栈状态，从而提供回溯;结合原始二进制文件中的符号和调试信息，调试器可以准确显示您是如何到达当前执行点的。

另一个有趣的输出是当前的辅助向量（AUXV），在“与程序的内核通信”一节中讨论。 386_TLS 描述了用于线程本地存储的 x86 实现的全局描述符表条目（有关使用分段的更多信息，请参阅“快速系统调用”一节，有关线程的信息，请参阅“线程”一节） 。

内核在当前 ulimit 设置的范围内创建核心转储文件 - 因为使用大量内存的程序可能导致非常大的转储，可能填满磁盘并使问题更严重，通常将 ulimit 设置为低或甚至零，因为大多数非开发人员几乎没有使用核心转储文件。然而，核心转储仍然是以 kill 后方式调试意外情况的最有用的方法。

## Custom sections

在大多数情况下，代码，数据和符号的组织是程序员可以放弃工具链默认值的东西。 但是，有时扩展或自定义部分及其内容是有意义的。 一个常见的例子是 Linux 内核模块，用于将驱动程序和其他功能动态加载到正在运行的内核中。 因为这些模块不可移植，所以只要它们只使用一个固定的内核构建版本，模块和内核之间的接口就可以灵活，并且不受特定标准的约束。 这意味着存储许可信息，作者身份，依赖关系和参数的方法可以由内核唯一地和完全地定义。

modinfo 工具可以检查模块中的此信息并将其呈现给用户。 下面我们使用 FUSE Linux 内核模块的示例，它允许用户空间库向内核提供文件系统实现。

```
$ cd /lib/modules/$(uname -r)
$ sudo modinfo ./kernel/fs/fuse/fuse.ko
$ objdump -s -j .modinfo ./kernel/fs/fuse/fuse.ko
```

如上所示，modinfo 正在解析模块文件中嵌入的.modinfo 部分，以显示模块的详细信息。 例 8.16“将模块信息放入部分”显示了如何将一个字段“作者”放入模块中。 代码主要来自 include / linux / module.h。

```c
 /*
     * Start at the bottom, and work your way up!
     */

    /* Indirect macros required for expanded argument pasting, eg. __LINE__. */
    #define ___PASTE(a,b) a##b
    #define __PASTE(a,b) ___PASTE(a,b)


    #define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)

    /* Indirect stringification.  Doing two levels allows the parameter to be a
     * macro itself.  For example, compile with -DFOO=bar, __stringify(FOO)
     * converts to "bar".
     */

    #define __stringify_1(x...)     #x
    #define __stringify(x...)       __stringify_1(x)

    #define __MODULE_INFO(tag, name, info)                                    \
    static const char __UNIQUE_ID(name)[]                                     \
      __used __attribute__((section(".modinfo"), unused, aligned(1)))         \
      = __stringify(tag) "=" info

    /* Generic info of form tag = "info" */
    #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)

    /*
     * Author(s), use "Name <email>" or just "Name", for multiple
     * authors use multiple MODULE_AUTHOR() statements/lines.
     */
    #define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)

    /* ---- */

    MODULE_AUTHOR("Your Name <your@name.com>");
```

起初，这看起来像一场宏观的噩梦，但它可以一步一步地解开。从底部开始，我们看到 MODULE_AUTHOR 是更通用的**MODULE_INFO 宏的包装器，这是大多数魔法发生的地方。在那里，我们可以看到我们正在构建一个静态 const char []变量来保存字符串“author = Your Name <your@name.com>”。有趣的是要注意的是变量有一个额外的参数**attribute \_\_（（section（“。modinfo”））），它告诉编译器不要将它放在数据部分中，包含所有其他变量，而是将其存放在其中。自己的 ELF 部分名为.modinfo。其他参数会停止正在优化的变量，因为它看起来未使用，并确保通过指定对齐方式将变量打包在彼此旁边。

广泛使用字符串化宏，这是 C 预处理器中使用的相当神秘的技巧，以确保字符串和定义可以共存。唯一的另一个技巧是使用 gcc 提供的**COUNTER**特殊定义，每次调用时都会提供一个唯一的递增值;这允许在一个文件中进行多次 MODULE_AUTHOR 调用，而不是以相同的变量名称结束。

我们可以检查最终模块中的符号以查看最终结果：

`$ objdump --syms ./fuse.ko | grep modinfo`

## Linker Scripts

在例 8.7“章节”中，我们描述了段在最终输出中如何组成段。 链接器的工作是将这些部分构建成段; 为了实现这一目标，它使用了一个链接描述文件来描述段的开始位置，进入它们的部分以及各种其他参数。

例 8.18，“默认链接描述文件”显示了默认链接描述文件的摘录，链接器在给出其详细标记时将通过指定-Wl， - verbose 到 gcc 来显示。 默认脚本内置于链接器，基于标准 API 定义，为构建平台创建工作用户空间程序。

```
1 $ gcc -Wl,--verbose -o test test.c
    GNU ld (GNU Binutils for Debian) 2.26
    ...
    using internal linker script:
  5 ==================================================
    OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
    	      "elf64-x86-64")
    OUTPUT_ARCH(i386:x86-64)
    ENTRY(_start)
 10 SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); ...
    SECTIONS
    {
      /* Read-only sections, merged into text segment: */
      PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
 15   .interp         : { *(.interp) }
      .note.gnu.build-id : { *(.note.gnu.build-id) }
      .hash           : { *(.hash) }
      .gnu.hash       : { *(.gnu.hash) }
      .dynsym         : { *(.dynsym) }
 20   .dynstr         : { *(.dynstr) }
      .gnu.version    : { *(.gnu.version) }
      .gnu.version_d  : { *(.gnu.version_d) }
      .gnu.version_r  : { *(.gnu.version_r) }
      .rela.dyn       :
 25     {
        ...
        }
      PROVIDE (etext = .);
      .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
 30   .rodata1        : { *(.rodata1) }
```

您可以粗略地看到链接描述文件如何指定诸如起始位置之类的内容以及要分组到各个段中的内容。 以同样的方式-Wl 用于通过 gcc 将--verbose 传递给链接器，可以通过标志提供自定义链接器脚本。 常规用户空间开发人员不太可能需要覆盖默认的链接描述文件。 但是，通常非常自定义的应用程序（如内核构建）需要自定义链接描
