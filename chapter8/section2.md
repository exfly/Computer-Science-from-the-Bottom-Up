# Representing executable files

## Three Standard Sections

至少，任何可执行文件格式都需要指定代码和数据在二进制文件中的位置。这些是可执行文件中的两个主要部分。

我们直到现在还没有提到的另一个组件是未初始化的全局变量的存储空间。如果我们声明一个变量并给它一个初始值，那么这个值需要存储在可执行文件中，以便在程序启动时它可以被初始化为正确的值。但是，当程序首次执行时，许多变量未初始化（或为零）。在可执行文件中为这些空间创建空间，然后简单地存储零或 NULL 值是浪费空间，不必要地膨胀磁盘上的可执行文件大小。因此，大多数二进制格式将附加 BSS 部分的概念定义为用于归零，未初始化数据的占位符大小。在程序加载时，可以分配 BSS 描述的额外内存（并设置为零！）。 BSS 可能代表 Block Started by Symbol，这是旧 IBM 计算机的汇编命令;确切的推导可能会失去历史。

## Binary Format

可执行文件由工具链从源代码创建。此文件需要采用明确定义的格式，以便编译器可以创建它，操作系统可以识别它并加载到内存中，将其转换为操作系统可以管理的正在运行的进程。这种可执行文件格式可以特定于操作系统，因为我们通常不希望为一个系统编译的程序将在另一个系统上执行（例如，您不希望您的 Windows 程序在 Linux 或 Linux 程序上运行）在 OS X 上运行）。

但是，所有可执行文件格式之间的共同点是它们包含一个预定义的标准化标题，该标题描述了程序代码和数据如何存储在文件的其余部分中。总之，它通常会描述“程序代码在这个文件中开始 20 个字节，长度为 50 千字节。程序数据跟随它，长度为 20 千字节”。

最近，一种特定格式已成为现代 UNIX 类型系统的可执行表示的事实标准。它被称为`Executable and Linker Format`，简称 ELF;我们很快就会更详细地研究它。

## Binary Format History

### a.out

ELF 并不总是标准; 原始 UNIX 系统使用名为 a.out 的文件格式。 如果编译没有-o 选项的程序来指定输出文件名，我们可以看到这种痕迹。 将使用默认名称 a.out 创建可执行文件。

a.out 是一种非常简单的标题格式，只允许单个数据，代码和 BSS 部分。 正如您将看到的，这对于具有动态库的现代系统来说是不够的。

### COFF

通用对象文件格式（或 COFF）是 ELF 的前身。 它的标题格式更灵活，允许文件中更多（但有限）的部分。

COFF 在共享库的优雅支持方面也存在困难，并且选择 ELF 作为 Linux 上的替代实现。

但是，COFF 作为可移植可执行文件或 PE 格式存在于 Microsoft Windows 中。 PE 是 Windows，因为 ELF 是 Linux。

![ELF Overview](http://www.bottomupcs.com/chapter07/figures/elf-overview.png)

## ELF File Header

总的来说，该文件有一个文件头，它通常描述文件，然后指向构成文件的每个单独部分。 例 8.1“ELF 标题”显示了 ELF32 的 API 文档（32 位形式的 ELF）中给出的描述。 这是定义 ELF 头的 C 结构的布局。

```c
typedef struct {
    unsigned char e_ident[EI_NIDENT];
    Elf32_Half    e_type;
    Elf32_Half    e_machine;
    Elf32_Word    e_version;
    Elf32_Addr    e_entry;
    Elf32_Off     e_phoff;
    Elf32_Off     e_shoff;
    Elf32_Word    e_flags;
    Elf32_Half    e_ehsize;
    Elf32_Half    e_phentsize;
    Elf32_Half    e_phnum;
    Elf32_Half    e_shentsize;
    Elf32_Half    e_shnum;
    Elf32_Half    e_shstrndx;
} Elf32_Ehdr;
```

`readelf --header /bin/ls`

例 8.2“ELF 标题，如 readelf 所示”表示由 readelf 程序提供的人类可读形式，它是 GNU binutils 的一部分。

`e_ident`数组是任何 ELF 文件开头的第一件事，并且始终以一些`magic`字节开头。 第一个字节是`0x7F`，然后接下来的三个字节是`ELF`。 您可以使用`hexdump`命令之类的内容检查 ELF 二进制文件以查看此内容。

hexdump -C /bin/ls | more

```
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  03 00 3e 00 01 00 00 00  e0 5a 00 00 00 00 00 00  |..>......Z......|
```

注意 0x7F 开始，然后是 ASCII 编码的“ELF”字符串。查看标准，看看数组的其余部分定义了什么以及二进制文件中的值是什么。

接下来，我们为这个二进制文件的机器类型设置了一些标志。我们可以看到的第一件事是 ELF 定义了不同类型大小的版本，一个用于 32 位，一个用于 64 位版本;在这里我们检查 32 位版本。区别主要在于 64 位机器地址显然需要保存在 64 位变量中。我们可以看到二进制文件是为大端机器创建的，它使用 2 的补码来表示负数。稍微减少我们可以看到机器告诉我们这是一个 PowerPC 二进制文件。

显然无害的切入点地址似乎很直接;这是程序代码从内存中开始的地址。初学 C 程序员被告知 main（）是你程序中调用的第一个程序。使用入口点地址，我们实际上可以验证它不是。

```sh
    $ cat test.c
    #include <stdio.h>

    int main(void)
    {
            printf("main is : %p\n", &main);
            return 0;
    }

    $ gcc -Wall -o test test.c

    $ ./test
    main is : 0x10000430

    $ readelf --headers ./test | grep 'Entry point'
      Entry point address:               0x100002b0

    $ objdump --disassemble ./test | grep 100002b0
    100002b0 <_start>:
    100002b0:       7c 29 0b 78     mr      r9,r1
```

在例 8.4“调查入口点”中，我们可以看到入口点实际上是一个名为\_start 的函数。 我们的程序根本没有对此进行定义，而主要的下划线表明它位于一个单独的命名空间中。 我们将在“启动程序”一节中详细介绍程序的启动方式。

之后，标题包含指向文件中 ELF 文件其他重要部分的起始位置的指针，如目录。

### Symbols and Relocations

ELF 规范提供了符号表，它只是字符串（符号）到文件中位置的映射。链接需要符号;例如，为声明为 extern int foo 的变量 foo 赋值;将要求链接器找到 foo 的地址，这将涉及在符号表中查找“foo”并查找地址。

与符号密切相关的是重定位。重新定位只是一个空白空间，以便稍后修补。在前面的示例中，直到 foo 的地址已知，才能使用它。但是，在 32 位系统上，我们知道 foo 的地址必须是 4 字节的值，所以编译器需要使用该地址时（比如说，分配一个值），它只需要留下 4 个字节的空白空间并保持一个重定位，基本上对链接器说“将”foo“的实际值放入此地址的 4 个字节中”。如上所述，这需要解析符号“foo”。名为“Relocations”的部分包含有关重定位的更多信息。

### Sections and Segments

ELF 格式指定 ELF 文件的两个“视图” - 用于链接的文件和用于执行的文件。 这为系统设计人员提供了极大的灵活性。

我们讨论等待链接到可执行文件的目标代码中的部分。 一个或多个部分映射到可执行文件中的段。

### Segments

正如我们之前所做的那样，在检查较低层之前，有时更容易查看更高级别的抽象（段）。

正如我们所提到的，ELF 文件有一个描述文件整体布局的标题。 ELF 头实际上指向另一组称为程序头的头。 这些头向操作系统描述了将二进制文件加载到内存并执行它所需的任何内容。 段由程序头描述，但是可执行文件运行所需的其他一些内容也是如此。

```c
typedef struct {
    Elf32_Word p_type;
    Elf32_Off  p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf32_Word p_filesz;
    Elf32_Word p_memsz;
    Elf32_Word p_flags;
    Elf32_Word p_align;
}
```

程序头的定义见例 8.5“程序头”。您可能已经注意到上面的 ELF 标头定义中有多少字段 e_phoff，e_phnum 和 e_phentsize;这些只是程序头开始的文件中的偏移量，有多少程序头以及每个程序头的大小。通过这三个信息，您可以轻松找到并读取程序头。

程序标题不仅仅是段。 p_type 字段定义程序头定义的内容。例如，如果此字段为 PT_INTERP，则标头定义为指向二进制文件的解释器的字符串指针。我们之前讨论过编译语言和解释语言，并区分了编译器构建一个可以独立运行的二进制文件。为什么需要翻译？与往常一样，真实情况有点复杂。现代系统在加载可执行文件时需要灵活性有几个原因，为此，只有在程序设置运行的实际时间才能充分获取某些信息。我们将在未来的章节中看到这一点，我们将研究动态链接。因此，可能需要对二进制文件进行一些小的更改，以使其在运行时正常工作。因此，二进制文件的通常解释器是动态加载器，因为它需要最后的步骤才能完成可执行文件的加载并准备二进制映像以便运行。

在 p_type 字段中使用值 PT_LOAD 描述段。然后，程序头中的其他字段描述每个段。 p_offset 字段告诉您磁盘上文件的距离是该段的数据。 p_vaddr 字段告诉您数据在虚拟内存中的存储地址（p_addr 描述了物理地址，这对于不实现虚拟内存的小型嵌入式系统非常有用）。两个标志 p_filesz 和 p_memsz 可以告诉你磁盘上的磁盘有多大以及它在内存中应该有多大。如果内存大小大于磁盘大小，则应使用零填充重叠。通过这种方式，您可以节省大量空间，而不必为空的全局变量浪费空间。最后，p_flags 表示该段的权限。可以任意组合指定执行，读取和写入权限;例如，代码段应该标记为只读和执行，数据段标记为 read 和 write，没有执行。

程序头中定义了一些其他段类型，它们在标准规范中有更全面的描述。

### Sections

正如我们所提到的，部分构成了细分。 节是将二进制文件组织成逻辑区域以在编译器和链接器之间传递信息的一种方法。 在某些特殊的二进制文件中，例如 Linux 内核，部分以更具体的方式使用（请参阅“自定义部分”一节）。

我们已经看到了段如何最终归结为磁盘上的文件中的数据 blob，其中描述了应该加载的位置以及它具有的权限。 节具有与段相似的标题，如例 8.6“节”中所示。

```c
typedef struct {
    Elf32_Word sh_name;
    Elf32_Word sh_type;
    Elf32_Word sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off  sh_offset;
    Elf32_Word sh_size;
    Elf32_Word sh_link;
    Elf32_Word sh_info;
    Elf32_Word sh_addralign;
    Elf32_Word sh_entsize;
}
```

节有几个为sh_type字段定义的类型; 例如，SH_PROGBITS类型的一部分被定义为一个包含二进制数据以供程序使用的部分。 其他标志表示此部分是否为符号表（例如链接器或调试器使用），或者可能是动态加载器的某些内容。 还有更多属性，例如allocate属性，用于标记此节将需要为其分配的内存。

下面我们将检查例8.7“章节”中列出的程序。

```c
#include <stdio.h>
int big_big_array[10*1024*1024];
char *a_string = "Hello, World!";
int a_var_with_value = 0x100;
int main(void)
{
	big_big_array[0] = 100;
	printf("%s\n", a_string);
	a_var_with_value += 20;
}
```

Example 8.8, “Sections readelf output ” shows the output of readelf with some parts stripped clarity. Using this output we can analyse each part of our simple program and see where it ends up in the final output binary.

`$ readelf --all ./sections`

首先，让我们看看变量big_big_array，顾名思义它是一个相当大的全局数组。如果我们跳到符号表，我们可以看到该变量位于0x100109cc位置，我们可以将其与列表中的.bss部分相关联，因为它在0x100109c8下面开始。注意尺寸，以及尺寸如何。我们提到BSS是二进制映像的标准部分，因为当所有空间都为零时，要求磁盘上的二进制文件分配10兆字节的空间是愚蠢的。请注意，此部分的NOBITS类型意味着它在磁盘上没有任何字节。

因此，.bss部分是为全局变量定义的，当程序启动时，其值应为零。我们已经看到在讨论段时内存大小如何与磁盘大小不同; .bss部分中的变量表示在程序启动时它们将被赋予零值。

a_string变量位于.sdata部分，代表小数据。小数据（以及相应的.sbss部分）是某些体系结构中可用的部分，其中数据可以通过来自某个已知指针的偏移量来到达。这意味着可以将固定值添加到基址，从而更快地获取部分中的数据，因为没有额外的查找和将地址加载到所需的内存中。大多数体系结构都限制为可以添加到寄存器的立即值的大小（例如，如果执行指令r1 = add r2,70;，70是立即值，而不是说，添加存储在寄存器中的两个值r1 = add r2，r3）因此只能偏离地址的某个“小”距离。我们还可以看到我们的a_var_with_value生活在同一个地方。

但是，正如我们所期望的那样，main存在于.text部分中（记住名称“text”和“code”可互换使用来指代内存中的程序。

## Sections and Segments together

`readelf --segments /bin/ls`

例8.9“Sections and Segments”显示了readelf如何向我们展示二进制文件/ bin / ls的ELF文件中的段和节映射。

跳到输出的底部，我们可以看到哪些部分已移动到哪些段中。因此，例如.interp部分被放置在INTERP标记的段中。请注意，readelf告诉我们它正在请求解释器/lib/ld.so.1;这是运行的动态链接器，用于准备二进制文件以供执行。

查看两个LOAD段，我们可以看到文本和数据之间的区别。注意第一个权限如何只有“读取”和“执行”权限，而下一个权限是否具有读取，写入和执行权限？这些描述了代码（r / w）和数据（r / w / e）段。

但是数据不应该是可执行的！实际上，在大多数体系结构（例如，最常见的x86）上，数据部分不会被标记为具有可执行的数据部分。但是，上面的示例输出来自PowerPC机器，该机器具有略微不同的编程模型（ABI，见下文），要求数据部分可执行。这就是系统程序员的生活，规则被打破了！

另一个值得注意的事情是文件大小与代码段的内存大小相同，但是内存大小大于数据段的文件大小。这来自BSS部分，其中包含零全局变量。
