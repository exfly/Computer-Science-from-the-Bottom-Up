# Compiling

## The process of compiling

将源文件编译为可执行文件的第一步是将代码从高级，人类可理解的语言转换为汇编代码。 我们从前面的章节中了解到汇编代码直接与处理器提供的指令和寄存器一起工作。

由于多种原因，编译器是最复杂的处理步骤。 首先，人类非常难以预测，其源代码有许多不同的形式。 编译器只对实际代码感兴趣，但是人类需要注释和空格（空格，制表符，缩进等）来理解代码。 编译器将人工编写的源代码转换为其内部表示的过程称为解析。

### C code

使用 C 代码，在解析称为预处理器的源代码之前实际上有一个步骤。 预处理器的核心是文本替换程序。 例如，声明为 `#define` 变量文本的任何变量都将变量替换为文本。 然后将这个预处理的代码传递给编译器。

## Syntax

任何计算语言都具有描述语言规则的特定语法。 您和编译器都知道语法规则，一切顺利，您将相互理解。 人类一如既往地经常忘记规则或打破规则，导致编译器无法理解你的意图。 例如，如果您将结束括号保留为 if 条件，则编译器不知道实际条件的位置。

语法最常用 Backus-Naur 形式（BNF）描述，这是一种可以用来描述语言的语言！

## Assembly Generation

编译器的工作是将更高级语言转换为适合于编译目标的汇编代码。 显然，每个不同的体系结构具有不同的指令集，不同数量的寄存器和用于正确操作的不同规则。

### Alignment

![Alignment](http://www.bottomupcs.com/chapter06/figures/alignment.png)

内存中变量的对齐是编译器的一个重要考虑因素。系统程序员需要了解对齐约束，以帮助编译器创建最有效的代码。

CPU 通常不能从任意存储器位置将值加载到寄存器中。它要求变量在某些边界上对齐。在上面的示例中，我们可以看到如何将 32 位（4 字节）值加载到需要 4 字节对齐变量的机器上的寄存器中。

第一个变量可以直接加载到寄存器中，因为它位于 4 个字节的边界之间。但是，第二个变量跨越 4 字节边界。这意味着至少需要两个负载才能将变量放入一个寄存器中;首先是下半部分然后是上半部分。

某些体系结构（如 x86）可以处理硬件中的未对齐负载，并且唯一的症状是性能较低，因为硬件会执行额外的工作以将值传入寄存器。其他架构不能违反对齐规则，并且会引发通常由操作系统捕获的异常，然后操作系统必须手动加载寄存器，从而导致更多的开销。

### Structure Padding

程序员需要考虑对齐，尤其是在创建结构时。 虽然编译器知道它正在构建的体系结构的对齐规则，但程序员有时可能会导致次优行为。

C99 标准仅表示结构将按照与声明中指定的顺序在内存中排序，并且在结构数组中，所有元素的大小都相同。

```cmd
$ cat struct.c
    #include <stdio.h>

    struct a_struct {
            char char_one;
            char char_two;
            int int_one;
    };

    int main(void)
    {

            struct a_struct s;

            printf("%p : s.char_one\n" \
                   "%p : s.char_two\n" \
                   "%p : s.int_one\n", &s.char_one,
                   &s.char_two, &s.int_one);

            return 0;

    }

    $ gcc -o struct struct.c

    $ gcc -fpack-struct -o struct-packed struct.c

    $ ./struct
    0x7fdf6798 : s.char_one
    0x7fdf6799 : s.char_two
    0x7fdf679c : s.int_one

    $ ./struct-packed
    0x7fcd2778 : s.char_one
    0x7fcd2779 : s.char_two
    0x7fcd277a : s.int_one

```

在上面的例子中，我们设计了一个具有两个字节的结构（字符后跟一个 4 字节的整数。编译器填充结构如下。

![padding](http://www.bottomupcs.com/chapter06/figures/padding.png)

在另一个例子中，我们指示编译器不要填充结构，相应地我们可以看到整数在两个字符之后直接开始。

## Cache line alignment

我们之前讨论了缓存中的别名，以及多个地址如何映射到同一缓存行。程序员需要确保在编写程序时不会导致缓存行的弹跳。

当程序不断访问映射到同一缓存行的两个内存区域时，会出现这种情况。这有效地浪费了缓存行，因为它被加载，使用了很短的时间，然后必须被踢出，另一个缓存行被加载到缓存中的相同位置。

显然，如果这种情况重复，性能将大大降低。如果冲突的数据以稍微不同的方式组织以避免缓存线冲突，那么情况将会得到缓解。

检测这种情况的一种可能方法是分析。在对代码进行概要分析时，您“观察”它以分析采用的代码路径以及执行所需的时间。通过配置文件引导优化（PGO），编译器可以在它构建的第一个二进制文件中放置特殊的额外代码，运行并记录所采用的分支等。然后，您可以使用额外信息重新编译二进制文件，以便创建一个更好的二进制。否则，程序员可以查看配置文件的输出，并可能检测缓存行弹跳等情况。

## Space - Speed Trade off(权衡)

上面的编译器使用一些额外的内存进行交换，以提高运行代码的速度。 编译器知道体系结构的规则，并且可以做出关于对齐数据的最佳方式的决策，可能通过折少少量浪费的内存来增加（或者甚至只是正确）性能。

因此，作为程序员，您永远不应该对编译器布置变量和数据的方式做出假设。 这样做是不可移植的，因为不同的体系结构可能具有不同的规则，并且编译器可以基于显式命令或优化级别做出不同的决定。

## Making Assumptions

因此，作为 C 程序员，您需要熟悉编译器将执行什么以及可能变量的内容。 您可以假设和不能假设的内容在 C99 标准中有详细说明; 如果你是用 C 语言编程，那么为了避免编写非便携或错误的代码而熟悉规则当然是值得的。

Stack alignment example：

```
$ cat stack.c
    #include <stdio.h>

    struct a_struct {
            int a;
            int b;
    };

    int main(void)
    {
            int i;
            struct a_struct s;
            printf("%p\n%p\ndiff %ld\n", &i, &s, (unsigned long)&s - (unsigned long)&i);
            return 0;
    }
    $ gcc-3.3 -Wall -o stack-3.3 ./stack.c
    $ gcc-4.0 -o stack-4.0 stack.c

    $ ./stack-3.3
    0x60000fffffc2b510
    0x60000fffffc2b520
    diff 16

    $ ./stack-4.0
    0x60000fffff89b520
    0x60000fffff89b524
    diff 4
```

在上面的示例中，从 Itanium 机器中，我们可以看到堆栈的填充和对齐在 gcc 版本之间发生了很大变化。 这种类型的东西是预期的，必须由程序员考虑。

通常，您应该确保不要对类型或对齐规则的大小做出假设。

## C 对齐的习语

有一些常见的代码序列可以处理对齐; 通常大多数程序会在某些方面考虑它。 在处理以某种形式处理数据块的程序时，您可能会在内核以外的许多地方看到这些“代码习惯用法”，因此值得研究。

我们可以从 Linux 内核中获取一些示例，这些示例通常需要处理系统内部页面的对齐。

```c
// [ include/asm-ia64/page.h ]

/*
    * PAGE_SHIFT determines the actual kernel page size.
    */
#if defined(CONFIG_IA64_PAGE_SIZE_4KB)
# define PAGE_SHIFT     12
#elif defined(CONFIG_IA64_PAGE_SIZE_8KB)
# define PAGE_SHIFT     13
#elif defined(CONFIG_IA64_PAGE_SIZE_16KB)
# define PAGE_SHIFT     14
#elif defined(CONFIG_IA64_PAGE_SIZE_64KB)
# define PAGE_SHIFT     16
#else
# error Unsupported page size!
#endif

#define PAGE_SIZE               (__IA64_UL_CONST(1) << PAGE_SHIFT)
#define PAGE_MASK               (~(PAGE_SIZE - 1))
#define PAGE_ALIGN(addr)        (((addr) + PAGE_SIZE - 1) & PAGE_MASK)
```

上面我们可以看到内核中的页面大小有很多不同的选项，范围从 4KB 到 64KB。

PAGE_SIZE 宏是相当自我解释的，通过将值 1 移动给给定的移位数来给出系统内选择的当前页面大小（记住，这相当于说 2n，其中 n 是 PAGE_SHIFT）。

接下来我们有 PAGE_MASK 的定义。 PAGE_MASK 允许我们只查找当前页面内的那些位，即页面内地址的偏移量。

# Optimization

一旦编译器具有代码的内部表示，编译器的真正有趣的部分就会启动。 编译器想要为给定的输入代码找到最优化的汇编语言输出。 这是一个庞大而多样的问题，需要从基于计算机科学的高效算法到有关运行代码的特定处理器的深入知识的所有知识。

编译器在生成输出时可以看到一些常见的优化。 生成最佳代码的策略还有很多，而且它始终是一个活跃的研究领域。

## General Optimizing

编译器可以把一些不应该使用的代码片段，将其优化为将特定语言构造优化为具有相同结果的较小代码。

## 展开循环（Unrolling loops）

如果代码包含一个循环，例如 for 或 while 循环，并且编译器知道它将执行多少次，则展开循环以使其顺序执行可能更有效。 这意味着不是执行循环内部然后分支回到开始重复该过程，而是重复内循环代码以再次执行。

虽然这增加了代码的大小，但是它可以允许处理器更有效地处理指令，因为分支可能导致进入处理器的指令流程中的低效率。

## Inlining functions

与展开循环类似，可以在被调用者中嵌入被调用的函数。 程序员可以通过在函数定义中将函数指定为内联来指定编译器应该尝试这样做。 再一次，您可以通过这样做在代码中按顺序交换代码大小。

## Branch Prediction

计算机遇到 if 语句时，有两种可能的结果; 对或错。 处理器希望尽可能保持其传入管道的完整性，因此在将代码放入管道之前，它不能等待测试结果。

因此，编译器可以预测测试可能采用的方式。 编译器可以使用一些简单的规则来猜测这样的事情，例如，如果（val == -1）可能不可能是真的，因为-1 通常表示错误代码，并且希望不会经常触发。

有些编译器实际上可以编译程序，让用户运行它并注意分支在实际条件下的运行方式。 然后它可以根据它看到的内容重新编译它。
