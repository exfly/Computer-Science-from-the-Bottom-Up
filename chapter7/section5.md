# Linker

通常在大型程序中，您将代码分成多个文件以将相关功能保持在一起。 这些文件中的每一个都可以编译成目标代码：但最终目标是创建一个可执行文件！ 需要以某种方式将这些目标文件中的每一个组合成单个可执行文件。 我们称之为链接。

请注意，即使您的程序确实适合一个文件，它仍然需要链接到某些系统库才能正常运行。 例如，printf 调用保存在库中，该库必须与您的可执行文件组合才能工作。 因此，虽然在这种情况下您没有明确地担心链接，但是大多数情况下仍然会发生创建可执行文件的链接过程。

在以下部分中，我们将解释一些理解链接所必需的术语。

## Symbols

变量和函数都有源代码中的名称，我们通过它们引用它们。 一种思考声明变量 int a 的语句的一种方法是，你告诉编译器“预留一些 sizeof（int）的内存，从现在开始，当我使用它时，它将引用这个分配的内存。同样，一个函数说” 将此代码存储在内存中，当我调用 function（）时跳转并执行此代码“。

在这种情况下，我们调用 a 和函数符号，因为它们是内存区域的符号表示。

符号有助于人类理解编程。 你可以说编译过程的主要工作是删除符号 - 处理器不知道代表什么，它只知道它在某个特定的内存地址有一些数据。 编译过程需要将+ = 2 转换为“将 0xABCDE 内存中的值递增 2”。

### 符号可见性（Symbol Visibility）

在某些 C 程序中，您可能已经看到了与变量一起使用的术语 static 和 extern。这些修饰符可以影响我们所谓的符号可见性。

想象一下，您已将程序拆分为两个文件，但某些功能需要共享一个变量。您只需要共享变量的一个定义（即内存位置）（否则它将不会被共享！），但两个文件都需要引用它。

为了实现这一点，我们将变量声明在一个文件中，然后在另一个文件中声明一个同名但带有前缀 extern 的变量。 extern 代表外部和人类意味着这个变量在其他地方声明。

extern 对编译器说的是它不应该在内存中为这个变量分配任何空间，并将此符号留在目标代码中，稍后将对其进行修复。编译器不可能知道符号实际定义的位置，而是链接器，因为它的作用是一起查看所有目标文件并将它们组合成单个可执行文件。因此链接器将在第二个文件中看到遗留的符号，并说“我在文件 1 中看到过该符号，我知道它指的是内存位置 0x12345”。因此，它可以将符号值修改为第一个文件中变量的内存值。

静态几乎与外部相反。它限制了它修改的符号的可见性。如果使用静态声明一个对编译器说“不要在目标代码中留下任何符号”的变量。这意味着当链接器将对象文件链接在一起时，它将永远不会看到该符号（因此不能使“我以前见过这个！”连接）。 static 适用于分离和减少冲突 - 通过声明变量 static，您可以在其他文件中重用变量名，而不是以符号冲突结束。我们说我们正在限制符号的可见性，因为我们不允许链接器看到它。将此与一个更明显的符号（一个未用静态声明的符号）进行对比，链接器可以看到它。

## The linking process

因此，链接过程实际上是两个步骤; 将所有目标文件合并为一个可执行文件，然后遍历每个目标文件以解析任何符号。 这通常需要两次通过; 一个用于读取所有符号定义并记录未解析的符号，另一个用于将所有未解析的符号固定到正确的位置。

最终的可执行文件最终应该没有未解析的符号; 如果存在错误，链接器将失败并显示错误。
