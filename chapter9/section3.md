# Global Offset Tables

在考虑共享库的目标时，您可能已经注意到重定位存在严重问题。我们之前提到过，虚拟内存共享库的一大优势是多个程序可以通过共享页面来使用内存中的代码。

问题源于 lib 无法保证将它们放入内存的位置。动态链接器将为每个所需的库找到虚拟内存中最方便的位置并将其放置在那里。如果不发生这种情况，请考虑替代方案;系统中的每个库都需要自己的虚拟内存块，以便不会有两个重叠。每次将新库添加到系统时都需要分配。有人可能会成为一头猪并写一个巨大的 lib，而不是为其他图书馆留下足够的空间！很有可能，你的程序无论如何都不想使用那个库。

因此，如果使用重定位修改共享库的代码，则该代码不再变为可共享。我们失去了共享库的优势。

下面我们解释这样做的机制。

## The Global Offset Table

因此，想象一下我们采用符号值的情况。 仅使用重定位，我们将让动态链接器查找该符号的内存地址并重新编写代码以加载该地址。

一个相当直接的增强是在我们的二进制文件中留出空间来保存该符号的地址，并让动态链接器将地址放在那里而不是直接放在代码中。 这样我们就不需要触摸二进制代码部分了。

为这些地址预留的区域称为全局偏移表或 GOT。 GOT 位于名为`.got`的 ELF 文件的一部分中。

![.got](http://www.bottomupcs.com/chapter08/figures/got-plt.png)

`.got`对每个进程都是私有的，并且进程必须具有写入权限。 相反，库代码是共享的，进程应该只对代码具有读取和执行权限; 如果流程可以修改代码，那将是一个严重的安全漏洞。

## The GOT in action

```
    $ cat got.c
    extern int i;

    void test(void)
    {
            i = 100;
    }

    $ gcc -nostdlib  -shared -o got.so ./got.c

    $ objdump --disassemble ./got.so

    ./got.so:     file format elf64-ia64-little

    Disassembly of section .text:

    0000000000000410 <test>:
     410:   0d 10 00 18 00 21       [MFI]       mov r2=r12
     416:   00 00 00 02 00 c0                   nop.f 0x0
     41c:   81 09 00 90                         addl r14=24,r1;;
     420:   0d 78 00 1c 18 10       [MFI]       ld8 r15=[r14]
     426:   00 00 00 02 00 c0                   nop.f 0x0
     42c:   41 06 00 90                         mov r14=100;;
     430:   11 00 38 1e 90 11       [MIB]       st4 [r15]=r14
     436:   c0 00 08 00 42 80                   mov r12=r2
     43c:   08 00 84 00                         br.ret.sptk.many b0;;

    $ readelf --sections ./got.so
    There are 17 section headers, starting at offset 0x640:

    Section Headers:
      [Nr] Name              Type             Address           Offset
           Size              EntSize          Flags  Link  Info  Align
      [ 0]                   NULL             0000000000000000  00000000
           0000000000000000  0000000000000000           0     0     0
      [ 1] .hash             HASH             0000000000000120  00000120
           00000000000000a0  0000000000000004   A       2     0     8
      [ 2] .dynsym           DYNSYM           00000000000001c0  000001c0
           00000000000001f8  0000000000000018   A       3     e     8
      [ 3] .dynstr           STRTAB           00000000000003b8  000003b8
           000000000000003f  0000000000000000   A       0     0     1
      [ 4] .rela.dyn         RELA             00000000000003f8  000003f8
           0000000000000018  0000000000000018   A       2     0     8
      [ 5] .text             PROGBITS         0000000000000410  00000410
           0000000000000030  0000000000000000  AX       0     0     16
      [ 6] .IA_64.unwind_inf PROGBITS         0000000000000440  00000440
           0000000000000018  0000000000000000   A       0     0     8
      [ 7] .IA_64.unwind     IA_64_UNWIND     0000000000000458  00000458
           0000000000000018  0000000000000000  AL       5     5     8
      [ 8] .data             PROGBITS         0000000000010470  00000470
           0000000000000000  0000000000000000  WA       0     0     1
      [ 9] .dynamic          DYNAMIC          0000000000010470  00000470
           0000000000000100  0000000000000010  WA       3     0     8
      [10] .got              PROGBITS         0000000000010570  00000570
           0000000000000020  0000000000000000 WAp       0     0     8
      [11] .sbss             NOBITS           0000000000010590  00000590
           0000000000000000  0000000000000000   W       0     0     1
      [12] .bss              NOBITS           0000000000010590  00000590
           0000000000000000  0000000000000000  WA       0     0     1
      [13] .comment          PROGBITS         0000000000000000  00000590
           0000000000000026  0000000000000000           0     0     1
      [14] .shstrtab         STRTAB           0000000000000000  000005b6
           000000000000008a  0000000000000000           0     0     1
      [15] .symtab           SYMTAB           0000000000000000  00000a80
           0000000000000258  0000000000000018          16    12     8
      [16] .strtab           STRTAB           0000000000000000  00000cd8
           0000000000000045  0000000000000000           0     0     1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings)
      I (info), L (link order), G (group), x (unknown)
      O (extra OS processing required) o (OS specific), p (processor specific)

```

上面我们创建一个简单的共享库，它引用一个外部符号。我们在编译时不知道这个符号的地址，所以我们将它留给动态链接器在运行时修复。

但我们希望我们的代码保持可共享，以防其他进程也想使用我们的代码。

反汇编揭示了我们如何用.got 做到这一点。在 IA64（编译库的体系结构）上，寄存器 r1 称为全局指针，并始终指向.got 部分加载到内存的位置。

如果我们看看 readelf 输出，我们可以看到.got 部分从库加载到内存之后的 0x10570 字节开始。因此，如果要将库加载到地址 0x6000000000000000 的内存中，则.got 将位于 0x6000000000010570，寄存器 r1 将始终指向此地址。

通过反汇编向后工作，我们可以看到我们将值 100 存储到寄存器 r15 中保存的存储器地址中。如果我们回顾一下，我们可以看到寄存器 15 保存了存储在寄存器 14 中的存储器地址的值。再往后一步，我们看到加载这个地址是通过向寄存器 1 添加一个小数字来找到的.GOT 只是一个大的长条目列表，每个外部变量一个。这意味着外部变量 i 的 GOT 条目存储为 24 个字节（即 3 个 64 位地址）。

```
$ readelf --relocs ./got.so
    Relocation section '.rela.dyn' at offset 0x3f8 contains 1 entries:
      Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000010588  000f00000027 R_IA64_DIR64LSB   0000000000000000 i + 0
```

我们也可以查看此条目的重定位。 重定位说“将偏移量 10588 处的值替换为符号 i 存储在的存储位置”。

我们知道.got 从前一个输出的偏移量 0x10570 开始。 我们还看到代码如何加载地址 0x18（十进制 24），给我们一个地址 `0x10570 + 0x18 = 0x10588` ...重定位的地址！

因此，在程序开始之前，动态链接器将修复重定位，以确保偏移量 0x10588 处的内存值是全局变量 i 的地址！
