# The Dynamic Linker

动态链接器是代表可执行文件管理共享动态库的程序。 它可以将库加载到内存中，并在运行时修改程序以调用库中的函数。

ELF 允许可执行文件指定解释器，解释器是应该用于运行可执行文件的程序。 编译器和静态链接器将依赖于动态库的可执行文件的解释器设置为动态链接器。

`readelf --headers /bin/ls`

```
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000033c8 0x00000000000033c8  R      0x1000
  LOAD           0x0000000000004000 0x0000000000004000 0x0000000000004000
                 0x0000000000012db1 0x0000000000012db1  R E    0x1000
  LOAD           0x0000000000017000 0x0000000000017000 0x0000000000017000
                 0x0000000000008890 0x0000000000008890  R      0x1000
  LOAD           0x0000000000020050 0x0000000000021050 0x0000000000021050
                 0x0000000000001218 0x0000000000002508  RW     0x1000
  DYNAMIC        0x0000000000020a98 0x0000000000021a98 0x0000000000021a98
                 0x00000000000001c0 0x00000000000001c0  RW     0x8
  NOTE           0x00000000000002c4 0x00000000000002c4 0x00000000000002c4
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x000000000001c1cc 0x000000000001c1cc 0x000000000001c1cc
                 0x00000000000008c4 0x00000000000008c4  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000020050 0x0000000000021050 0x0000000000021050
                 0x0000000000000fb0 0x0000000000000fb0  R      0x1
...
```

您可以在上面看到解释器设置为`/lib64/ld-linux-x86-64.so.2`，它是动态链接器。 当内核加载二进制文件以供执行时，它将检查`PT_INTERP`字段是否存在，如果是，则将其指向的内容加载到内存中并启动它。

我们提到动态链接的可执行文件留下了需要使用在运行时之前不可用的信息修复的引用，例如共享库中函数的地址。 留下的引用称为重定位。

## Relocations

动态链接器的基本部分是在运行时修复地址，这是您可以确定在内存中加载某些内容的唯一时间。 可以简单地将重定位视为需要在加载时修复特定地址的注释。 在代码准备好运行之前，您需要浏览并读取所有重定位并修复它所指向的地址以指向正确的位置。

| Address  |        Action        |
| -------- | :------------------: |
| 0x123456 | Address of symbol "x |
| 0x564773 |      Function X      |

每种体系结构都有许多类型的重定位，每种类型的确切行为都记录为系统的 ABI 的一部分。 搬迁的定义非常简单。

```c
typedef struct {
    Elf32_Addr    r_offset;  <--- address to fix
    Elf32_Word    r_info;    <--- symbol table pointer and relocation type
}

typedef struct {
    Elf32_Addr    r_offset;
    Elf32_Word    r_info;
    Elf32_Sword   r_addend;
} Elf32_Rela;
```

`r_offset`字段指的是文件中需要修复的偏移量。 `r_info`字段指定重定位的类型，该类型描述了修复此代码必须完成的操作。通常为架构定义的最简单的重定位只是符号的值。在这种情况下，您只需在指定位置替换符号的地址，并且重定位已“固定”。

这两种类型，一种带有加数，另一种没有指定不同的重定位操作方式。加数只是应该添加到固定地址以找到正确地址的东西。例如，如果重定位是符号 i，因为原始代码正在执行类似 i 的操作，则加数将设置为 8.这意味着“找到 i 的地址，然后转到 8”。

该加数值需要存储在某个地方。两种形式涵盖了这两种解决方案。在`REL`表单中，加数实际上存储在程序代码中的固定地址所在的位置。这意味着要正确修复地址，您需要先读取要修复的内存以获取任何加数，存储，找到“真实”地址，添加加数然后再写回来（通过加数）。 `RELA`格式指定重定位中的加数。

每种方法的权衡应该是明确的。使用 REL，您需要在修复之前执行额外的内存引用以查找加数，但是您不会在二进制文件中浪费空间，因为您使用了重定位目标内存。使用`RELA`，您可以将加数保留在重定位中，但会浪费磁盘二进制文件中的空间。大多数现代系统都使用 `RELA` 重定位。

## Relocations in action

下面的示例显示了重定位的工作原理。 我们创建了两个非常简单的共享库，并在另一个库中引用了一个。

```
    $ cat addendtest.c
    extern int i[4];
    int *j = i + 2;

    $ cat addendtest2.c
    int i[4];

    $ gcc -nostdlib -shared -fpic -s -o addendtest2.so addendtest2.c
    $ gcc -nostdlib -shared -fpic -o addendtest.so addendtest.c ./addendtest2.so

    $ readelf -r ./addendtest.so

    Relocation section '.rela.dyn' at offset 0x3b8 contains 1 entries:
      Offset          Info           Type           Sym. Value    Sym. Name + Addend
    0000000104f8  000f00000027 R_IA64_DIR64LSB   0000000000000000 i + 8
```

因此，我们在`addendtest.so`中有一个类型为`R_IA64_DIR64LSB`的重定位。 如果你在`IA64 ABI`中查看它，可以将其缩写为

- `R_IA64`：所有重定位都以此前缀开头。
- `DIR64`：64 位直接类型重定位
- `LSB`：由于`IA64`可以在大端和小端模式下运行，因此这种重定位是小端（最低有效字节）。

`ABI`继续说这种重新定位意味着“重新定位指向的符号的值，加上任何数”。 我们可以看到我们的加数为 8，因为 `sizeof(int)==4` 并且我们已经将两个 int 移动到数组中`(* j = i + 2)`。 因此，在运行时，要修复此重定位，您需要找到符号 i 的地址并将其值加上 8 加到`0x104f8`中。

## Position Independence

在可执行文件中，代码和数据段在虚拟内存中被赋予指定的基址。 可执行代码不是共享的，每个可执行文件都有自己的新地址空间。 这意味着编译器确切地知道数据部分的位置，并且可以直接引用它。

`LIB`没有这样的保证。 他们可以知道他们的数据部分将是与基地址的指定偏移量; 但确切地说，基地址只能在运行时知道。

因此，所有库都必须使用可以执行的代码生成，无论它放在何处放入内存，称为位置无关代码（或简称 PIC）。 请注意，数据部分仍然是代码部分的固定偏移量; 但要实际找到数据的地址，需要将偏移量添加到加载地址。
