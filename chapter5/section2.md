# 进程(process)的元素(elements)

![The Elements of a Process](http://www.bottomupcs.com/chapter04/figures/theprocess.png)

## Process ID

进程 ID（或 PID）由操作系统分配，并且对于每个正在运行的进程都是唯一的。

## Memory

我们将在接下来的几周内准确了解进程如何获取内存 - 它是操作系统工作方式中最基本的部分之一。但是，现在知道每个进程都有自己的内存部分就足够了。

在此存储器中，存储所有程序代码，以及变量和任何其他分配的存储。

内存的一部分可以在进程之间共享（称为共享内存，这并不奇怪）。在较旧的操作系统中进行原始实现后，您经常会看到这称为 System Five Shared Memory（或 SysV SHM）。

进程可以使用的另一个重要概念是将磁盘上的文件 mmaping 到内存。这意味着，不必打开文件并使用诸如 read（）和 write（）之类的命令，该文件看起来就像是任何其他类型的 RAM 一样。 mmaped 区域具有读取，写入和执行等权限，需要对其进行跟踪。我们知道，维护安全性和稳定性是操作系统的工作，因此需要检查进程是否尝试写入只读区域并返回错误。

### Code and Data

进程可以进一步分为代码和数据部分。 程序代码和数据应该分开保存，因为它们需要来自操作系统的不同权限，并且分离有助于共享代码（如后所述）。 操作系统需要授予程序代码读取和执行权限，但通常不会写入。 另一方面，数据（变量）需要读写权限，但不应该是可执行的.

### The Stack

进程的另一个非常重要的部分是称为栈(stack)的内存区域。 这可以被视为流程数据部分的一部分，并且与任何程序的执行密切相关。

栈是通用数据结构，其工作方式与堆栈板完全相同; 你可以推一个项目（把盘子放在一堆盘子的顶部），然后成为顶级项目，或者你可以弹出一个项目（取下一个盘子，露出前一个盘子）。

栈是函数调用的基础。 每次调用一个函数时，它都会获得一个新的栈帧。 这是一个内存区域，通常至少包含完成时返回的地址，函数的输入参数和局部变量的空间。

按照惯例，栈通常会逐渐减少。 这意味着栈从内存中的高地址开始并逐渐降低。

![The Stack](http://www.bottomupcs.com/chapter04/figures/stack.png)

我们可以看到堆栈如何带来函数的许多功能。

每个函数都有自己的输入参数副本。这是因为每个函数都分配了一个新的堆栈帧，其参数位于新的内存区域。

这就是为什么其他函数无法看到函数内定义的变量的原因。全局变量（可由任何函数看到）保存在数据存储器的单独区域中。

这有利于递归调用。这意味着函数可以自由地再次调用自身，因为将为其所有局部变量创建新的堆栈帧。

每个帧包含要返回的地址。 C 只允许从函数返回单个值，因此按照惯例，此值将返回到指定寄存器中的调用函数，而不是堆栈上。

因为每个帧都有一个对它之前的引用，所以调试器可以向后“向前走”，跟随栈中的指针。由此可以生成一个堆栈跟踪，显示所有被调用的函数通向此函数。这对于调试非常有用。

您可以看到函数的工作方式如何完全符合堆栈的本质。任何函数都可以调用任何其他函数，然后它成为最多函数（放在堆栈顶部）。最终该函数将返回到调用它的函数（将自己从堆栈中取出）。

堆栈会使调用函数变慢，因为值必须移出寄存器并进入内存。有些架构允许参数直接在寄存器中传递;但是为了保持每个函数获得寄存器必须旋转的每个参数的唯一副本的语义。

您可能听说过堆栈溢出这个术语。这是通过传递虚假值来破解系统的常见方式。如果您作为程序员接受任意输入到堆栈变量（例如，从键盘或通过网络读取），您需要明确说明数据的大小。

允许任何数量的数据未经检查只会覆盖内存。通常这会导致崩溃，但是有些人意识到如果他们覆盖了足够的内存以在堆栈帧的返回地址部分放置特定值，那么当函数完成而不是返回到正确的位置（从中调用它的地方） ）他们可以让它返回他们刚发送的数据。如果该数据包含破坏系统的二进制可执行代码（例如，为具有 root 权限的用户启动终端），那么您的计算机已被盗用。

这是因为堆栈向下增长，但数据是“向上”读取的（即从较低地址到较高地址）。

有几种方法可以解决这个问题;首先，作为程序员，您必须确保始终检查您在变量中接收的数据量。操作系统可以通过确保堆栈被标记为不可执行来帮助代表程序员避免这种情况;也就是说，即使恶意用户试图将某些代码传递给您的程序，处理器也不会运行任何代码。现代架构和操作系统支持此功能。

堆栈最终由编译器管理，因为它负责生成程序代码。 对于操作系统，堆栈看起来就像进程的任何其他内存区域。

为了跟踪堆栈的当前增长，硬件将寄存器定义为堆栈指针。 编译器（或编程器在汇编器中写入时）使用该寄存器来跟踪堆栈的当前顶部。

```
    $ cat sp.c
void function(void){
            int i = 100;
            int j = 200;
            int k = 300;
}

    $ gcc -fomit-frame-pointer -S sp.c

    $ cat sp.s
            .file   "sp.c"
            .text
    .globl function
            .type   function, @function
    function:
            subl    $16, %esp
            movl    $100, 4(%esp)
            movl    $200, 8(%esp)
            movl    $300, 12(%esp)
            addl    $16, %esp
            ret
            .size   function, .-function
            .ident  "GCC: (GNU) 4.0.2 20050806 (prerelease) (Debian 4.0.1-4)"
            .section        .note.GNU-stack,"",@progbits
```

上面我们展示了一个简单的函数，在堆栈上分配三个变量。 反汇编说明了在 x86 架构上使用堆栈指针[14]。 首先，我们在堆栈上为局部变量分配一些空间。 由于堆栈增长，我们从堆栈指针中保存的值中减去。 值 16 是一个足以容纳我们的局部变量的值，但可能不是所需的大小（例如，使用 3 个 4 字节的 int 值，我们实际上只需要 12 个字节，而不是 16 个）来保持堆栈在内存中的对齐 编译器需要的某些边界。

然后我们将值移动到堆栈内存中（在实际函数中，使用它们）。 最后，在返回到我们的父函数之前，我们通过将堆栈指针移回到我们开始之前的位置来“弹出”堆栈中的值。

### The Heap

堆是由进程管理的内存区域，用于即时内存分配。这适用于在编译时未知存储器要求的变量。

堆的底部称为`brk`，因此需要系统调用来修改它。通过使用`brk`调用向下扩展该区域，进程可以请求内核分配更多内存供其使用。

堆通常由`malloc`库调用管理。这使得程序员可以通过简单地分配和释放（通过空闲调用）堆内存来轻松管理堆。 `malloc`可以使用像伙伴分配器这样的方案来管理用户的堆内存。 `malloc`也可以更智能地分配，并可能使用匿名`mmaps`来获得额外的进程内存。这是将文件 mmaping 到进程内存而不是直接映射系统 RAM 区域的地方。这可以更有效。由于正确管理内存的复杂性，任何现代程序直接调用`brk`是非常罕见的。

### Memory Layout

![Process memory layout](http://www.bottomupcs.com/chapter04/figures/memory-layout.png)

正如我们所看到的，进程分配了较小的内存区域，每个区域都有特定的用途。

上面给出了如何由内核在存储器中布置过程的示例。 从顶部开始，内核在进程的顶部保留了一些内存（我们在虚拟内存中看到这些内存实际上是如何在所有进程之间共享的）。

下面是 mmaped 文件和库的空间。 下面是堆栈，下面是堆。

底部是程序映像，从磁盘上的可执行文件加载。 我们将在后面的章节中详细介绍加载此数据的过程。

## File Descriptors

在第一周，我们了解了 stdin，stdout 和 stderr; 每个进程的默认文件。 您会记住，这些文件始终具有相同的文件描述符编号（分别为 0,1,2）。

因此，内核为每个进程单独保存文件描述符。

文件描述符也具有权限。 例如，您可以从文件中读取但不能写入文件。 打开文件时，操作系统会在文件描述符中保留对该文件的进程权限的记录，并且不允许进程执行任何不应执行的操作。

## Registers

我们从前一章了解到，处理器基本上对寄存器中的值执行通常简单的操作。 这些值被读取（和写入）到内存 - 我们在上面提到过，每个进程都分配了内核跟踪的内存。

因此，等式的另一面是跟踪寄存器。 当当前正在运行的进程放弃处理器以便另一个进程可以运行时，它需要保存其当前状态。 同样，当进程有更多时间在 CPU 上运行时，我们需要能够恢复此状态。 为此，操作系统需要将 CPU 寄存器的副本存储到存储器中。 当进程再次运行时，操作系统会将寄存器值从内存复制回 CPU 寄存器，然后进程将从中断处继续。

## Kernel State

在内部，内核需要跟踪每个进程的许多元素。

### Process State

操作系统跟踪的另一个重要元素是进程状态。 如果进程当前正在运行，则将其置于运行状态是有意义的。

但是，如果进程已请求从磁盘读取文件，我们从内存层次结构中知道这可能需要很长时间。 该进程应放弃其当前执行以允许另一个进程运行，但内核不需要让进程再次运行，直到磁盘中的数据在内存中可用。 因此，它可以将进程标记为磁盘等待（或类似），直到数据准备就绪。

### Priority

有些流程比其他流程更重要，并且获得更高的优先级。 请参阅下面有关调度程序的讨论。

### Statistics

内核可以保存每个进程行为的统计信息，这可以帮助它决定进程的行为; 例如，它主要是从磁盘读取还是主要进行 CPU 密集型操作？
