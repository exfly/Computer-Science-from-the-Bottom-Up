# Signals

在系统中运行的进程需要一种方式来告知影响它们的事件。在 UNIX 上，内核和进程之间存在称为信号的基础结构，允许进程接收有关对其重要的事件的通知。

当信号发送到进程时，内核调用一个处理程序，该进程必须向内核注册以处理该信号。处理程序只是代码中的一个设计函数，专门用于处理中断。通常，信号将从内核本身发送，但是一个进程将信号发送到另一个进程（进程间通信的一种形式）也很常见。信号处理程序被异步调用;那就是当前正在运行的程序因处理信号事件而中断。

例如，当按下 ctrl-c 组合时，一种类型的信号是中断（在系统头中定义为 SIGINT）传递给进程。

当一个进程使用 read 系统调用来从键盘读取输入时，内核将观察输入流以寻找特殊字符。如果它看到 ctrl-c，它将跳转到信号处理模式。内核将查看进程是否已为此中断注册了处理程序。如果有，则执行将传递给函数将处理它的函数。如果进程没有为此特定信号注册处理程序，那么内核将采取一些默认操作。使用 ctrl-c，默认操作是终止进程。

进程可以选择忽略某些信号，但不允许忽略其他信号。例如，SIGKILL 是应该终止进程时发送的信号。内核将看到该进程已发送此信号并终止进程运行，没有问题。该进程不能要求内核忽略该信号，并且内核非常小心允许哪个进程将该信号发送到另一个进程;除非您是 root 用户，否则您只能将其发送给您拥有的进程。您可能已经看过命令 kill -9;这来自 SIGKILL 信号的实现。众所周知，SIGKILL 实际上定义为 0x9，因此当指定为 kill 程序的参数时，意味着指定的进程将立即停止。由于该过程不能选择忽略或处理此信号，因此该程序将被视为最后的途径，因为该程序将无法清理或退出。首先将 SIGTERM（终止）发送到进程被认为是更好的，如果它已经崩溃或者不会退出，那么请求 SIGKILL。作为惯例，大多数程序将为 SIGHUP 安装一个处理程序（挂断 - 从串行终端和调制解调器的几天遗留下来），它将重新加载程序，可能是为了获取配置文件或类似文件中的更改。

如果您已在 Unix 系统上编程，则在尝试读取或写入尚未分配给您的内存时，您将熟悉分段错误。当内核注意到你正在触摸分配之外的内存时，它会向你发送分段故障信号。通常，进程不会为此安装处理程序，因此终止程序的默认操作会随之发生（因此程序“崩溃”）。在某些情况下，程序可能会为分段错误安装处理程序，但这样做的原因是有限的。

这就提出了接收信号后会发生什么的问题。信号处理程序完成运行后，控制权将返回到从中断处继续的进程。

## Example

以下简单的程序介绍了很多运行的信号！

```c
    $ cat signal.c
    #include <stdio.h>
    #include <unistd.h>
    #include <signal.h>

    void sigint_handler(int signum)
    {
            printf("got SIGINT\n");
    }

    int main(void)
    {
            signal(SIGINT, sigint_handler);
            printf("pid is %d\n", getpid());
            while (1)
                    sleep(1);
    }
    $ gcc -Wall -o signal signal.c
    $ ./signal
    pid is 2859
    got SIGINT # press ctrl-c
               # press ctrl-z
    [1]+  Stopped                 ./signal

    $ kill -SIGINT 2859
    $ fg
    ./signal
    got SIGINT
    Quit # press ctrl-\
```

我们有简单的程序，只需定义 SIGINT 信号的处理程序，当用户按下 ctrl-c 时发送该处理程序。系统的所有信号都在 signal.h 中定义，包括允许我们注册处理功能的信号功能。

该程序只是在紧急循环中无所事事直到它退出。当我们启动程序时，我们尝试按 ctrl-c 使其退出。而不是采取默认操作，或调用处理程序，我们得到预期的输出。

然后我们按 ctrl-z 发送一个 SIGSTOP，默认情况下进程进入休眠状态。这意味着它不会被放入队列中以供调度程序运行，因此在系统中处于休眠状态。

作为说明，我们使用 kill 程序从另一个终端窗口发送相同的信号。这实际上是通过 kill 系统调用实现的，它接受一个信号和 PID 发送给（这个函数有点错误，因为并非所有信号实际上都会杀死进程，正如我们所看到的那样，但是信号函数已经被注册了处理程序）。当进程停止时，信号将排队等待进程。这意味着内核会记录信号，并在适当的时候提供信号。

此时，我们使用命令 fg 唤醒进程。这实际上会向进程发送 SIGCONT 信号，默认情况下会将进程唤醒。内核知道将进程放在运行队列上并再次给它 CPU 时间。我们在这一点上看到排队的信号被传递。

绝望地摆脱程序，我们最终尝试 ctrl- \发送 SIGQUIT（中止）到进程。但如果进程中止，Quit 输出来自哪里？

你猜对了，更多的信号！当父子进程死亡时，它会收到 SIGCHLD 信号。在这种情况下，shell 是父进程，因此它得到了信号。还记得我们如何通过等待调用来获取需要通过子进程获取返回代码的僵尸进程吗？另外，它还给父母一个孩子可能已经死亡的信号。因此，shell 知道子进程死于 SIGABRT，并且信息服务为用户打印了多少（当子进程从 SIGSEGV 死亡时，同样的进程打印出“Segmentation Fault”）。

您可以看到即使是一个简单的程序，也可以使用大约 5 种不同的信号在进程和内核之间进行通信并保持运行。还有许多其他信号，但这些信号肯定是最常见的。大多数都具有由内核定义的系统功能，但是有一些信号保留给用户在他们的程序（SIGUSR）中用于他们自己的目的。
