# Fork and Exec

新的进程由两个相关的接口 fork 和 exec 创建。

## Fork

当你来到隐喻的“岔路口”时，你通常有两种选择，你的决定会影响你的未来。 计算机程序在遇到 fork（）系统调用时会到达这个分支。

此时，操作系统将创建一个与父进程完全相同的新进程。 这意味着复制了之前讨论过的所有状态，包括打开文件，寄存器状态和所有内存分配，其中包括程序代码。

系统调用的返回值是进程可以确定它是现有进程还是新进程的唯一方法。 父进程的返回值将是子进程的 ID（PID），而子进程的返回值为 0。

此时，我们说该进程已分叉，并且我们具有如上所述的父子关系。

## exec

Forking 为现有进程提供了一种启动新进程的方法，但是新进程与父进程不属于同一个进程的情况又如何呢？ shell 中就是这种情况; 当用户启动命令时，它需要在新进程中运行，但它与 shell 无关。

这是 exec 系统调用发挥作用的地方。 exec 将使用程序二进制文件中的信息替换当前正在运行的进程的内容。

因此，shell 在启动新程序时遵循的过程首先是 fork，创建一个新进程，然后 exec（即加载到内存中并执行）它应该运行的程序二进制文件。

## Linux 实际如何处理 fork 和 exec

### clone

在内核中，fork 实际上是通过克隆系统调用实现的。 此克隆接口有效地提供了 Linux 内核如何创建进程的抽象级别。

clone 允许您明确指定将新进程的哪些部分复制到新进程中，以及在两个进程之间共享哪些部分。 这一开始看起来有点奇怪，但允许我们通过一个非常简单的界面轻松实现线程。

### Threads

虽然 fork 复制了我们上面提到的所有属性，但想象一下除了内存之外是否为新进程复制了所有属性。 这意味着父和子共享相同的内存，其中包括程序代码和数据。

![Threads](http://www.bottomupcs.com/chapter04/figures/threads.png)

这个混合子被称为线程。与使用 fork 的地方相比，线程有许多优点

1. 单独的进程无法看到彼此的记忆。它们只能通过其他系统调用相互通信。

但是，线程共享相同的内存。因此，您拥有多个进程的优势，并且不必须使用系统调用来在它们之间进行通信。

这引起的问题是线程可以很容易地踩到彼此的脚趾。一个线程可能会增加一个变量，另一个线程可能会减少它而不通知第一个线程。这些类型的问题称为并发问题，它们有很多种。

为了帮助解决这个问题，有一些用户空间库可以帮助程序员正确地处理线程。最常见的一种称为 POSIX threads，或者通常称为`pthreads`

2. 切换过程非常昂贵，其中一项主要开支是跟踪每个进程正在使用的内存。通过共享内存，可以避免这种开销，并且可以显着提高性能。

有许多不同的方法来实现线程。一方面，用户空间实现可以在进程内实现线程，而内核不知道它。线程看起来都像是在一个进内核程中运行。

这不是最理想的，主要是因为内核正在保留有关系统中正在运行的内容的信息。确保尽可能以最佳方式利用系统资源是内核的工作，如果内核认为单个进程实际上运行多个线程，则可能会做出次优决策。

因此另一种方法是内核完全了解线程。在 Linux 下，这是通过使所有进程能够通过克隆系统调用共享资源来建立的。每个线程仍然具有关联的内核资源，因此内核可以在进行资源分配时将其考虑在内。

其他操作系统有一个混合方法，其中一些线程可以指定只在用户空间运行（从内核“隐藏”），而其他线程可能是一个轻量级进程，类似的指示内核，进程是一个线程的一部分组。

### Copy on write

正如我们所提到的，在调用 fork 时将一个进程的整个内存复制到另一个进程是一项昂贵的操作。

一种优化称为写入时复制。 这意味着类似于上面的线程，当调用 fork 时，内存实际上是在两个进程之间共享而不是复制。 如果进程只是在读取内存，那么实际上不需要复制数据。

但是，当进程写入其内存时，它需要是不共享的私有副本。 顾名思义，copy on write 通过仅在写入时执行内存的实际副本来优化此操作。

copy on write 对 exec 也有很大的优势。 由于 exec 只是用新程序覆盖所有内存，实际上复制内存会浪费很多时间。 写入时复制可以节省我们实际复制的内容。

### The init process

我们之前讨论了 init 过程的总体目标，现在我们可以了解它是如何工作的。

在启动时，内核启动 init 进程，然后分叉并执行系统引导脚本。这些 fork 和 exec 执行更多程序，最终结束了分支登录过程。

init 进程的另一项工作是“收获”。当进程使用返回代码调用 exit 时，父进程通常要检查此代码以查看子进程是否正确退出。

但是，此退出代码是刚刚调用 exit 的进程的一部分。所以这个过程“死”（例如没有运行）但仍然需要保持不变直到收集返回代码。在这种状态下的过程被称为僵尸（你可以与神秘的僵尸对比的特征！）

进程保持为僵尸状态，直到父进程使用等待调用收集返回代码。但是，如果父母在收集此返回代码之前退出，那么僵尸进程仍然存在，漫无目的地等待将其状态提供给某人。

在这种情况下，僵尸子进程将被重新分配给 init 进程，该进程有一个特殊的处理程序来获取返回值。因此，该过程最终是免费的，并且可以从内核进程表中删除描述符。

```
$ cat zombie.c
    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
            pid_t pid;

            printf("parent : %d\n", getpid());

            pid = fork();

            if (pid == 0) {
                    printf("child : %d\n", getpid());
                    sleep(2);
                    printf("child exit\n");
                    exit(1);
            }
            /* in parent */
            while (1)
            {
                    sleep(1);
            }
    }

    ianw@lime:~$ ps ax | grep [z]ombie
    16168 pts/9    S      0:00 ./zombie
    16169 pts/9    Z      0:00 [zombie] <defunct>
```

上面我们创建了一个僵尸进程。 父进程将永远休眠，而孩子将在几秒钟后退出。

在代码下方，您可以看到运行程序的结果。 父进程（16168）处于睡眠状态 S（正如我们所期望的）并且子进入 Zombie 的状态 Z. ps 输出还告诉我们该过程在过程描述中已不存在。
