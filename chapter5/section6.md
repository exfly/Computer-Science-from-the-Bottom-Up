# Scheduling

正在运行的系统有许多进程，甚至可能有数百或数千个进程。 跟踪所有这些进程的内核部分称为调度程序，因为它会调度下一个应该运行的进程。

调度算法有很多种。 大多数用户都有与他们希望计算机做什么相关的不同目标，因此这会影响调度决策。 例如，对于台式 PC，您希望确保桌面图形应用程序有足够的时间运行，即使系统进程需要更长时间。 这将增加用户感受到的响应性，因为他们的行为将有更多的即时响应。 对于服务器，您可能希望优先使用 Web 服务器应用程序。

人们总是提出新的算法，你可以很容易地想到自己的算法。 但是有许多不同的调度组件。

## 抢先 vs 合作调度 (Preemptive v co-operative scheduling)

调度策略大致可分为两类

- 合作调度是当前运行的进程自愿放弃执行以允许另一个进程运行的地方。 这样做的明显缺点是，该过程可能决定永不放弃执行，可能是因为某个形式的无限循环导致的错误，因此没有其他任何东西可以运行。

- 抢占式调度是中断进程以阻止其他进程运行的地方。 每个进程都有一个时间片来运行; 在每个上下文切换点，定时器将被复位，并在时间片结束时传送和中断。

我们知道硬件独立于运行过程处理中断，因此此时控制将返回操作系统。 此时，调度程序可以决定下一个要运行的进程。

这是所有现代操作系统使用的调度类型。

## 实时的

有些进程需要准确知道它们的时间片有多长，以及它们在获得另一个时间片之前需要多长时间。 假设你有一个运行心肺机的系统; 你不希望下一个脉冲被延迟，因为其他东西决定在系统中运行！

硬实时系统可以保证调度决策，例如流程在再次运行之前中断的最长时间。 它们通常用于医疗，飞机和军事应用等生命关键应用。

软实时是对此的一种变化，其中保证不是那么严格，但一般的系统行为是可预测的。 Linux 可以像这样使用，它经常用于处理音频和视频的系统中。 如果您正在录制音频流，则不希望长时间中断，因为您将丢失无法检索的音频数据。

## 物超所值（Nice value）

简要介绍一下 Linux Scheduler

随着新开发人员尝试改进其行为，Linux 调度程序已经并且正在经历许多变化。

当前的调度程序称为 O（1）调度程序，它指的是无论调度程序必须选择多少进程的属性，它都会选择下一个在恒定时间内运行的程序[17]。

Linux 调度程序的先前版本使用良好的概念来确定下一个要运行的进程。 所有可能的任务都保存在运行队列中，运行队列只是内核知道处于“可运行”状态（即不等待磁盘活动或以其他方式睡眠）的进程链接列表。 出现的问题是，要计算下一个运行过程，每个可能的可运行过程必须计算其良好性，并且具有最高性能的“胜利”过程。 您可以看到，对于更多任务，确定接下来将运行哪些进程将花费更长时间。

![The O(1) scheduler](http://www.bottomupcs.com/chapter04/figures/o1queue.png)

相反，O（1）调度程序使用如上所示的运行队列结构。运行队列具有优先级顺序的多个存储桶以及用于标记哪些存储桶具有可用进程的位图。查找下一个要运行的进程是读取位图以查找具有进程的第一个存储桶，然后从该存储桶的队列中选择第一个进程。调度程序保留两个这样的结构，一个是活动的和过期的数组，用于可运行的进程和分别利用它们的整个时间片的进程。当所有进程都有一些 CPU 时间时，可以通过简单地修改指针来交换它们。

然而，真正有趣的部分是如何确定进程应该在运行队列中的哪个位置。需要考虑的一些事情是良好的级别，处理器关联性（保持进程与它们运行的 ​​ 处理器相关联，因为将进程移动到 SMP 系统中的另一个 CPU 可能是一项昂贵的操作）并提供更好的支持用于识别交互式程序（诸如 GUI 的应用程序，其可能花费很多时间睡觉，等待用户输入，但是当用户确实需要与其进行交互时想要快速响应）。
