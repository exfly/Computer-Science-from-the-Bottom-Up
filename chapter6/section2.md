# What virtual memory is

虚拟内存就是利用地址空间。

处理器的地址空间是指在加载和存储到存储器时可以使用的可能地址范围。 地址空间受寄存器宽度的限制，因为我们知道要加载一个地址，我们需要发出一个加载指令，加载地址从存储在寄存器中加载。 例如，32 位宽的寄存器可以保存 0x00000000 到 0xFFFFFFF 寄存器范围内的地址。 2 ^ 32 等于 4GB，因此 32 位处理器可以加载或存储高达 4GB 的内存。

## 64 bit computing

新处理器通常都是 64 位处理器，顾名思义就是 64 位宽的寄存器。 作为练习，您应该计算出这些处理器可用的地址空间（提示：它很大！）。

对于使用较小的位宽处理器，64 位计算确实存在一些权衡。 以 64 位模式编译的每个程序都需要 8 字节指针，这会增加代码和数据大小，从而影响指令和数据缓存性能。 但是，64 位处理器往往有更多的寄存器，这意味着当编译器处于寄存器压力下时，不需要将临时变量保存到存储器。

## Canonical Addresses

虽然 64 位处理器具有 64 位宽的寄存器，但系统通常不会实现所有 64 位的寻址 - 实际上不可能加载或存储到所有 16 EB 的理论物理内存！

636/5000
大多数体系结构都定义了一个未实现的地址空间区域，处理器认为该区域无效。 x86-64 和 Itanium 都定义了地址的最高有效位，然后必须对其进行符号扩展（请参阅“符号扩展”一节）以创建有效地址。 其结果是总地址空间有效地分为上部和下部两部分，其间的地址被认为是无效的。 这在图 6.1“规范地址的图示”中说明。 有效地址称为规范地址（无效地址是非规范地址）。

![Figure 6.1. Illustration of canonical addresses](http://www.bottomupcs.com/chapter05/figures/canonical.png)

通常可以通过使用其信息指令查询处理器本身来找到处理器的确切最高有效位值。 虽然确切的值取决于实现，但典型值为 48; 提供 248 = 256 TiB 的可用地址空间。

像这样减少可能的地址空间意味着可以在处理器和相关组件中对寻址逻辑的所有部分进行大量节省，因为他们知道他们不需要处理完整的 64 位地址。 由于实现将高位定义为带符号扩展，因此这防止了使用这些位的便携式操作系统存储或标记附加信息并确保在实现希望将来实现更多地址空间时的兼容性。

## Using the address space

与操作系统的大多数组件一样，虚拟内存充当地址空间和系统中可用的物理内存之间的抽象。 这意味着当程序使用地址时，地址不会引用内存中实际物理位置的位。

所以为此，我们说程序使用的所有地址都是虚拟的。 操作系统跟踪虚拟地址以及如何将它们分配给物理地址。 当程序从地址加载或存储时，处理器和操作系统一起工作以将该虚拟地址转换为系统存储器芯片中的实际地址。
