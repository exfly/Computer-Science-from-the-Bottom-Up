# Linux Specifics

虽然虚拟内存的基本概念保持不变，但实现的细节高度依赖于操作系统和硬件。

## Address Space Layout

Linux 将可用的地址空间划分为共享内核组件和私有用户空间地址。 这意味着地址空间的内核端口中的地址映射到每个进程的相同物理内存，而用户空间地址对进程是私有的。 在 Linux 上，共享内核空间位于可用地址空间的最顶层。 在最常见的处理器上，32 位 x86，这种拆分发生在 3GB 点。 由于 32 位可以映射最大 4GB，因此共享内核区域的前 1GB

![Linux address space layout](http://www.bottomupcs.com/chapter05/figures/linux-layout.png)

## Three Level Page Table

操作系统有许多不同的方式来组织页表，但 Linux 选择使用分层系统。

由于页表使用三层深度的层次结构，因此 Linux 方案通常称为三级页表。事实证明，三级页面表是强有力的选择，尽管它并非没有批评。每个处理器的虚拟内存实现的细节各不相同，这意味着 Linux 选择的通用页表必须是可移植的并且相对通用。

三级页表的概念并不难。我们已经知道虚拟地址由页面编号和物理内存页面中的偏移量组成。在三级页表中，虚拟地址进一步分为数级。

每个级别都是它自己的页面表;即，它映射物理页面的页码。在单级页面表中，“级别 1”条目将直接映射到物理帧。在多级版本中，每个上层都给出了保存下一个较低级别页表的物理内存帧的地址。

![Linux Three Level Page Table](http://www.bottomupcs.com/chapter05/figures/threelevel.png)

因此，示例引用涉及转到顶级页表，查找下一级地址所在的物理帧，读取该级别表以及查找下一级页表所在的物理帧，依此类推。

起初，这个模型似乎是不必要的复杂。实施此模型的主要原因是出于尺寸考虑。想象一下只有一个页面映射到其虚拟地址空间末端的进程的理论情况。我们之前说过，页表条目是从页表基址寄存器中找到的，因此页表需要是内存中的连续数组。因此，靠近地址空间末尾的单个页面需要整个阵列，这可能占用相当大的空间（很多很多物理页面的内存）。

在三级系统中，第一级只是一个物理内存帧。这映射到第二级，它再次只是一帧内存，第二级也是第三级。因此，三级系统将所需页数减少到仅为单级系统所需的页数的一小部分。

该系统存在明显的缺点。查找单个地址需要更多参考，这可能很昂贵。 Linux 理解这个系统可能不适合许多不同类型的处理器，因此每个体系结构都可以折叠页表以轻松地降低级别（例如，最常见的体系结构 x86，在其实现中仅使用两级系统） ）。
