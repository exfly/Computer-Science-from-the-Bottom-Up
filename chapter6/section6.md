# Virtual Addresses

当程序访问内存时，它不知道或关心支持地址的物理内存存储在何处。 它知道操作系统和硬件一起工作以映射定位正确的物理地址，从而提供对所需数据的访问。 因此，我们将程序用于访问存储器的地址称为虚拟地址。 虚拟地址由两部分组成; 页面和该页面的偏移量。

## Page

由于整个可能的地址空间被划分为常规大小的页面，因此每个可能的地址都驻留在页面内。 虚拟地址的页面组件充当页表的索引。 由于页面是系统内最小的内存分配单元，因此在页面非常小的情况下需要进行权衡，因此操作系统需要管理很多页面，并使页面变大但可能浪费内存

## Offset

虚拟地址的最后几位称为偏移量，它是您想要的字节地址与页面起始位置之间的位置差异。 您需要在偏移量中有足够的位才能到达页面中的任何字节。 对于 4K 页面，您需要（4K ==（4 \* 1024）== 4096 == 212 ==）12 位偏移量。 请记住，操作系统或硬件处理的最小内存量是一个页面，因此这些 4096 个字节中的每一个都驻留在一个页面中，并作为“一个”处理。

## Virtual Address Translation

虚拟地址转换是指找出哪个物理页面映射到哪个虚拟页面的过程。

在将虚拟地址转换为物理地址时，我们只处理页码。 该过程的本质是获取给定地址的页码并在页面表中查找以查找指向物理地址的指针，虚拟地址的偏移量将添加到该物理地址，从而给出系统中的实际位置 记忆。

由于页表在操作系统的控制之下，如果页表中不存在虚拟地址，则操作系统知道进程正在尝试访问尚未分配给它的内存和 不允许访问。

![ual Address Translation](http://www.bottomupcs.com/chapter05/figures/virtaddress.png)

我们可以通过前面的简单线性页表示例来完成此操作。我们计算出使用4KiB页面时，32位地址空间需要一个1048576个表的表。因此，为了映射理论地址0x80001234，第一步是移除偏移位。在这种情况下，对于4KiB页面，我们知道我们有12位（212 == 4096）的偏移量。所以我们将右移12位虚拟地址，留下0x80001。因此（以十进制表示）线性页表的行524289中的值将是对应于该页面的物理帧。

您可能会看到线性页表的问题：由于必须考虑每个页面，无论是否使用，物理线性页表对于64位地址空间是完全不切实际的。考虑一个64位的地址空间，分为（宽大）64 KiB页面创建264/216 = 252页面进行管理;假设每个页面需要一个指向物理位置的8字节指针，则页面表总共需要252/23 = 249或512 GiB的连续内存！