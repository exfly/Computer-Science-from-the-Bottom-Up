# Hardware Support

到目前为止，我们只提到硬件与操作系统一起实现虚拟内存。 然而，我们已经掩盖了究竟如何发生的细节。

虚拟内存必然完全依赖于硬件架构，每个架构都有自己的细微之处。 但是，硬件中的虚拟内存有一些通用元素。

## Physical v Virtual Mode

所有处理器都有一些在物理或虚拟模式下运行的概念。 在物理模式下，硬件期望任何地址都将引用实际系统内存中的地址。 在虚拟模式下，硬件知道需要转换地址以查找其物理地址。

在许多处理器中，这两种模式简称为物理和虚拟模式。 Itanium 就是这样一个例子。 最常见的处理器 x86 在虚拟内存之前几天就有很多包袱，所以这两种模式被称为真实和保护模式。 实现保护模式的第一个处理器是 386，即使是未使用的 x86 系列中最现代的处理器仍然可以执行实模式。 在实模式中，处理器实现称为分段的存储器组织形式。

### Issues with segmentation

分段实际上只是一个有趣的历史记录，因为虚拟内存使其不太相关。 分段有许多缺点，对于没有经验的程序员来说，这是非常困惑的，虚拟内存系统主要是为了绕过而发明的。

在分段中，存在许多寄存器，其保存作为段的开始的地址。 获取内存中地址的唯一方法是将其指定为这些段寄存器之一的偏移量。 段的大小（以及因此可以指定的最大偏移量）由可用于从段基址寄存器偏移的位数确定。 在 x86 中，最大偏移量为 16 位，或者仅为 64K [18]。 如果想要使用超过 64K 的地址，这会导致各种各样的破坏，当内存增长到兆字节（现在是千兆字节）时，对于完全失败而言，这会带来轻微的不便。

![Segmentation](http://www.bottomupcs.com/chapter05/figures/segmentation.png)

在上图中，有三个段寄存器都指向段。 最大偏移量（受可用位数限制）由阴影显示。 如果程序需要超出此范围的地址，则必须重新配置段寄存器。 这很快就成了一个主要的烦恼。 另一方面，虚拟内存允许程序指定任何地址，操作系统和硬件可以完成翻译到物理地址的艰苦工作。

## The TLB

Translation Lookaside Buffer（或简称 TLB）是负责虚拟内存的处理器的主要组件。 它是处理器内部虚拟页面到物理帧转换的缓存。 操作系统和硬件一起工作以在系统运行时管理 TLB。

### Page Faults

当请求硬件的虚拟地址时 - 例如通过请求获取某些数据的加载指令 - 处理器在其 TLB 中查找虚拟地址到物理地址转换。如果它具有有效的转换，则可以将其与偏移部分组合以直接进入物理地址并完成加载。

但是，如果处理器无法在 TLB 中找到转换，则处理器必须引发页面错误。这类似于操作系统必须处理的中断（如前所述）。

当操作系统出现页面错误时，需要通过它的页面表来查找正确的转换并将其插入 TLB。

如果操作系统在页表中找不到翻译，或者如果操作系统检查有问题的页面的权限并且该进程未被授权访问它，则操作系统必须终止该进程。如果您曾经看到过分段错误（或段错误），那么这就是操作系统会杀死超出其范围的进程。

如果找到翻译，并且 TLB 当前已满，则需要删除一个翻译，然后才能插入另一个翻译。删除可能在将来使用的翻译没有意义，因为您将承担再次在页表中查找条目的成本。 TLB 通常使用类似于最近最少使用或 LRU 算法的东西，其中最旧的未使用的翻译被弹出以支持新的翻译。

然后可以再次尝试访问，并且一切顺利，应该在 TLB 中找到并正确翻译。

### Finding the page table

当我们说操作系统在页表中找到转换时，询问操作系统如何找到具有页表的内存是合乎逻辑的。

页表的基础将保存在与每个进程关联的寄存器中。 这通常称为页表基址寄存器或类似的。 通过获取该寄存器中的地址并向其添加页码，可以找到正确的条目。

### Other page related faults

TLB 通常可以生成另外两个重要错误，这些错误有助于管理访问和脏页面。每个页面通常包含一个位的形式的属性，该属性标记页面是否已被访问或是否为脏。

访问的页面只是已访问的任何页面。当页面翻译最初加载到 TLB 时，页面可以被标记为已被访问（否则为什么要加载它？[19]）

操作系统可以定期浏览所有页面并清除所访问的位，以了解当前正在使用的页面。当系统内存变满并且操作系统选择要交换到磁盘的页面时，显然那些访问位未被重置的页面是最佳的删除候选者，因为它们的使用时间最长。

脏页是一个写入数据的页面，因此不匹配磁盘上已有的任何数据。例如，如果页面是从交换加载的，然后由进程写入，则在将其移出交换之前，需要更新其磁盘副本。一个干净的页面没有任何变化，因此我们不需要将页面复制回磁盘的开销。

两者都相似，它们有助于操作系统管理页面。一般概念是页面有两个额外的位;脏位和访问位。当页面被放入 TLB 时，这些位被设置为指示 CPU 应该引发故障。

当进程尝试引用内存时，硬件会执行通常的转换过程。但是，它还会进行额外检查以查看是否未设置所访问的标志。如果是这样，它会向操作系统发出错误，操作系统应设置该位并允许该过程继续。类似地，如果硬件检测到它正在写入没有设置脏位的页面，则会引发操作系统将页面标记为脏的错误。

## TLB Management

我们可以说硬件使用的 TLB 是由软件管理的。 操作系统需要使用正确的条目加载 TLB 并删除旧条目。

### Flushing the TLB

从 TLB 中删除条目的过程称为刷新。更新 TLB 是维护进程的单独地址空间的关键部分;因为每个进程可以使用相同的虚拟地址而不更新 TLB 意味着进程可能最终覆盖另一个进程内存（相反，在共享地址空间的线程是你想要的情况下，因此 TLB 不会刷新在同一进程中切换线程）。

在某些处理器上，每次有上下文切换时，都会刷新整个 TLB。这可能非常昂贵，因为这意味着新进程必须经历整个页面错误的过程，在页面表中查找页面并插入翻译。

其他处理器实现额外的地址空间 ID（ASID），该 ID 被添加到每个 TLB 转换以使其唯一。这意味着每个地址空间（通常是每个进程，但记住线程想要共享相同的地址空间）获取自己的 ID，该 ID 与 TLB 中的任何转换一起存储。因此，在上下文切换时，TLB 不需要刷新，因为下一个进程将具有不同的地址空间 ID，即使它要求相同的虚拟地址，地址空间 ID 也会不同，因此转换为物理页面将与众不同。此方案可减少刷新并提高整体系统性能，但需要更多 TLB 硬件来保存 ASID 位。

通常，这是通过将附加寄存器作为包括 ASID 的过程状态的一部分来实现的。在执行虚拟到物理转换时，TLB 会查询此寄存器，并仅匹配与当前正在运行的进程具有相同 ASID 的条目。当然，该寄存器的宽度决定了 ASID 的可用数量，因此具有性能影响。有关处理器体系结构中 ASID 的示例，请参阅“地址空间”一节。

### Hardware v Software loaded TLB

而对 TLB 中最终结果的控制是操作系统的域;这不是全部故事。 “页面错误”一节中描述的过程描述了向操作系统引发的页面错误，该操作系统遍历页面表以查找虚拟到物理转换并将其安装在 TLB 中。这将被称为软件加载的 TLB - 但还有另一种选择;硬件加载的 TLB。

在硬件加载的 TLB 中，处理器体系结构定义了页表信息的特定布局（称为“页面+帧=页表”的部分，必须遵循该部分才能进行虚拟地址转换。响应访问虚拟地址如果 TLB 中没有，处理器将自动遍历页表以加载正确的转换条目。只有当转换条目不存在时，处理器才会引发由操作系统处理的异常。

在专用硬件中实现页表遍历在查找翻译时提供了速度优势，但却降低了可能希望为页表实现替代方案的操作系统实现者的灵活性。

所有架构都可以大致分为这两种方法。稍后，我们将研究一些常见的体系结构及其虚拟内存支持。
